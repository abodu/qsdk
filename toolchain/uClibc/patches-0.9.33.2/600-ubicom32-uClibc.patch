--- a/Rules.mak
+++ b/Rules.mak
@@ -524,6 +524,19 @@ ifeq ($(TARGET_ARCH),i960)
       SYMBOL_PREFIX=_
 endif
 
+ifeq ($(TARGET_ARCH),ubicom32)
+ifeq ($(UCLIBC_FORMAT_FDPIC_ELF),y)
+	CPU_CFLAGS-y	:= -mfdpic
+	CPU_LDFLAGS-y	+= -Wl,-melf32ubicom32fdpic
+endif
+	OPTIMIZATION+=-fstrict-aliasing
+# We based the ISA version choice on the ISA selection coming from
+# the kernel, so these are not CONFIG_UC_XXXX.
+	CPU_CFLAGS-$(CONFIG_UBICOM32_V3)	+= -march=ubicom32v3 -DUBICOM32_ARCH_VERSION=3
+	CPU_CFLAGS-$(CONFIG_UBICOM32_V4)	+= -march=ubicom32v4 -DUBICOM32_ARCH_VERSION=4
+	CPU_CFLAGS-$(CONFIG_UBICOM32_V5)	+= -march=ubicom32v5 -DUBICOM32_ARCH_VERSION=5
+endif
+
 ifeq ($(TARGET_ARCH),v850)
       SYMBOL_PREFIX=_
 endif
--- a/extra/Configs/Config.in
+++ b/extra/Configs/Config.in
@@ -105,6 +105,9 @@ config TARGET_sh64
 config TARGET_sparc
 	bool "sparc"
 
+config TARGET_ubicom32
+	bool "ubicom32"
+
 config TARGET_v850
 	bool "v850 (BROKEN)"
 
@@ -206,6 +209,10 @@ if TARGET_sparc
 source "extra/Configs/Config.sparc"
 endif
 
+if TARGET_ubicom32
+source "extra/Configs/Config.ubicom32"
+endif
+
 if TARGET_v850
 source "extra/Configs/Config.v850"
 endif
--- a/extra/Configs/Config.in.arch
+++ b/extra/Configs/Config.in.arch
@@ -7,7 +7,6 @@
 #
 # Binary format
 #
-if !ARCH_USE_MMU
 choice
 	prompt "Target File Format"
 config UCLIBC_FORMAT_ELF
@@ -15,7 +14,6 @@ config UCLIBC_FORMAT_ELF
 	depends on ARCH_USE_MMU
 config UCLIBC_FORMAT_FDPIC_ELF
 	bool "FDPIC ELF"
-	depends on !ARCH_USE_MMU && (TARGET_bfin || TARGET_frv)
 	select DOPIC
 config UCLIBC_FORMAT_DSBT_ELF
 	bool "DBST ELF"
@@ -37,10 +35,6 @@ config UCLIBC_FORMAT_SHARED_FLAT
 	  Pick this one if you are using uClinux and wish to build
 	  uClibc as a flat-format shared library.
 endchoice
-endif
-if ARCH_USE_MMU
-comment "Using ELF file format"
-endif
 
 config UCLIBC_SHARED_FLAT_ID
 	int "Shared library ID"
--- /dev/null
+++ b/extra/Configs/Config.ubicom32
@@ -0,0 +1,50 @@
+#
+# For a description of the syntax of this configuration file,
+# see extra/config/Kconfig-language.txt
+#
+
+config TARGET_ARCH
+	string
+	default "ubicom32"
+
+config FORCE_OPTIONS_FOR_ARCH
+	bool
+	default y
+	select ARCH_BIG_ENDIAN
+
+choice
+	prompt "Target Processor Architecture"
+	default CONFIG_UC_UBICOM32_V3
+	help
+	  This selects the instruction set architecture of your Ubicom32 CPU. This
+	  information is used for optimizing purposes. To build a library that
+	  will run on any Ubicom32 CPU, you can specify "v3" here.
+	  If you pick anything other than "v3," there is no
+	  guarantee that uClibc will even run on anything other than the
+	  selected processor type.
+
+	  You should probably select the Ubicom32 ISA that best matches the
+	  CPU you will be using on your device. uClibc will be tuned
+	  for that architecture.
+
+	  If you don't know what to do, choose "v3"
+
+config CONFIG_UC_UBICOM32_V3
+	bool "ISA v3"
+	select ARCH_HAS_NO_MMU
+
+config CONFIG_UC_UBICOM32_V4
+	bool "ISA v4"
+	select ARCH_HAS_NO_MMU
+
+config CONFIG_UC_UBICOM32_V5
+	bool "ISA v5"
+	select ARCH_HAS_MMU
+	select ARCH_USE_MMU if ARCH_HAS_MMU
+endchoice
+
+config ARCH_CFLAGS
+	string
+
+config CROSS
+	string
--- a/include/elf.h
+++ b/include/elf.h
@@ -338,6 +338,8 @@ typedef struct
 
 #define EM_XSTORMY16		0xad45
 
+#define EM_UBICOM32 	        0xde3d	/* Ubicom32; no ABI */
+
 /* FRV magic number - no EABI available??.  */
 #define EM_CYGNUS_FRV	0x5441
 
@@ -3141,6 +3143,54 @@ typedef Elf32_Addr Elf32_Conflict;
 #define R_MICROBLAZE_COPY 21  /* runtime copy */
 #define R_MICROBLAZE_NUM 22
 
+/* Ubicom32 ELF relocation types */
+#define R_UBICOM32_NONE 		0
+#define R_UBICOM32_16 			1
+#define R_UBICOM32_32 			2
+#define R_UBICOM32_LO16 		3
+#define R_UBICOM32_HI16 		4
+#define R_UBICOM32_21_PCREL 		5
+#define R_UBICOM32_24_PCREL 		6
+#define R_UBICOM32_HI24 		7
+#define R_UBICOM32_LO7_S 		8
+#define R_UBICOM32_LO7_2_S 		9
+#define R_UBICOM32_LO7_4_S 		10
+#define R_UBICOM32_LO7_D 		11
+#define R_UBICOM32_LO7_2_D 		12
+#define R_UBICOM32_LO7_4_D 		13
+#define R_UBICOM32_32_HARVARD 		14
+#define R_UBICOM32_LO7_CALLI 		15
+#define R_UBICOM32_LO16_CALLI 		16
+#define R_UBICOM32_GOT_HI24		17
+#define R_UBICOM32_GOT_LO7_S		18
+#define R_UBICOM32_GOT_LO7_2_S		19
+#define R_UBICOM32_GOT_LO7_4_S		20
+#define R_UBICOM32_GOT_LO7_D		21
+#define R_UBICOM32_GOT_LO7_2_D		22
+#define R_UBICOM32_GOT_LO7_4_D		23
+#define R_UBICOM32_FUNCDESC_GOT_HI24	24
+#define R_UBICOM32_FUNCDESC_GOT_LO7_S	25
+#define R_UBICOM32_FUNCDESC_GOT_LO7_2_S 26
+#define R_UBICOM32_FUNCDESC_GOT_LO7_4_S 27
+#define R_UBICOM32_FUNCDESC_GOT_LO7_D	28
+#define R_UBICOM32_FUNCDESC_GOT_LO7_2_D 29
+#define R_UBICOM32_FUNCDESC_GOT_LO7_4_D 30
+#define R_UBICOM32_GOT_LO7_CALLI	31
+#define R_UBICOM32_FUNCDESC_GOT_LO7_CALLI 32
+#define R_UBICOM32_FUNCDESC_VALUE	33
+#define R_UBICOM32_FUNCDESC		34
+#define R_UBICOM32_GOTOFFSET_LO		35
+#define R_UBICOM32_GOTOFFSET_HI		36
+#define R_UBICOM32_FUNCDESC_GOTOFFSET_LO 37
+#define R_UBICOM32_FUNCDESC_GOTOFFSET_HI 38
+#define R_UBICOM32_GNU_VTINHERIT	200
+#define R_UBICOM32_GNU_VTENTRY		201
+
+/* Ubicom32 Flags. */
+#define EF_UBICOM32_VMASK	0x0000ffff	/* version mask */
+#define EF_UBICOM32_PIC		0x80000000      /* -fpic */
+#define EF_UBICOM32_FDPIC	0x40000000      /* -mfdpic */
+
 #ifdef	__cplusplus
 }
 #endif
--- a/include/features.h
+++ b/include/features.h
@@ -448,4 +448,10 @@ uClibc was built without large file supp
 # include <libc-internal.h>
 #endif
 
+#ifndef libc_hidden_proto
+#define libc_hidden_proto(name, attrs...)
+#endif
+#ifndef libm_hidden_proto
+#define libm_hidden_proto(name, attrs...)
+#endif
 #endif	/* features.h  */
--- /dev/null
+++ b/ldso/ldso/ubicom32/dl-debug.h
@@ -0,0 +1,72 @@
+/* vi: set sw=4 ts=4: */
+/* Ubicom32 ELF shared library loader suppport
+ *
+ * Copyright (c) 2009		Ubicom Inc.
+ * Copyright (c) 1994-2000 Eric Youngdale, Peter MacDonald,
+ *                              David Engel, Hongjiu Lu and Mitch D'Souza
+ * Copyright (C) 2001-2004 Erik Andersen
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. The name of the above contributors may not be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+static const char *_dl_reltypes_tab[] =
+{
+	"R_UBICOM32_NONE", /* 0 */
+	"R_UBICOM32_16",
+	"R_UBICOM32_32",
+	"R_UBICOM32_LO16",
+	"R_UBICOM32_HI16",
+	"R_UBICOM32_21_PCREL", /* 5 */
+	"R_UBICOM32_24_PCREL",
+	"R_UBICOM32_HI24",
+	"R_UBICOM32_LO7_S",
+	"R_UBICOM32_LO7_2_S",
+	"R_UBICOM32_LO7_4_S", /* 10 */
+	"R_UBICOM32_LO7_D",
+	"R_UBICOM32_LO7_2_D",
+	"R_UBICOM32_LO7_4_D",
+	"R_UBICOM32_32_HARVARD",
+	"R_UBICOM32_LO7_CALLI", /* 15 */
+	"R_UBICOM32_LO16_CALLI",
+	"R_UBICOM32_GOT_HI24",
+	"R_UBICOM32_GOT_LO7_S",
+	"R_UBICOM32_GOT_LO7_2_S"
+	"R_UBICOM32_GOT_LO7_4_S", /* 20 */
+	"R_UBICOM32_GOT_LO7_D",
+	"R_UBICOM32_GOT_LO7_2_D",
+	"R_UBICOM32_GOT_LO7_4_D",
+	"R_UBICOM32_FUNCDESC_GOT_HI24	24",
+	"R_UBICOM32_FUNCDESC_GOT_LO7_S", /* 25 */
+	"R_UBICOM32_FUNCDESC_GOT_LO7_2_S",
+	"R_UBICOM32_FUNCDESC_GOT_LO7_4_S",
+	"R_UBICOM32_FUNCDESC_GOT_LO7_D",
+	"R_UBICOM32_FUNCDESC_GOT_LO7_2_D",
+	"R_UBICOM32_FUNCDESC_GOT_LO7_4_D", /* 30 */
+	"R_UBICOM32_GOT_LO7_CALLI",
+	"R_UBICOM32_FUNCDESC_VALUE",
+	"R_UBICOM32_FUNCDESC",
+#if 1
+	[200] "R_UBICOM32_GNU_VTINHERIT" , "R_UBICOM32_GNU_VTENTRY"
+#endif
+};
--- /dev/null
+++ b/ldso/ldso/ubicom32/dl-inlines.h
@@ -0,0 +1,39 @@
+/* Copyright (C) 2012, Qualcomm, Inc.
+ * Based on ../bfin/dl-inlines.h
+ * Copyright (C) 2003, 2004 Red Hat, Inc.
+ * Contributed by Alexandre Oliva <aoliva@redhat.com>
+ * Copyright (C) 2006-2011 Analog Devices, Inc.
+ *
+ * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+ */
+
+#define __dl_loadaddr_unmap __dl_loadaddr_unmap
+
+#include "../fdpic/dl-inlines.h"
+
+static __always_inline void
+__dl_loadaddr_unmap(struct elf32_fdpic_loadaddr loadaddr,
+                    struct funcdesc_ht *funcdesc_ht)
+{
+	int i;
+
+	for (i = 0; i < loadaddr.map->nsegs; i++) {
+		struct elf32_fdpic_loadseg *segdata;
+		ssize_t offs;
+		segdata = loadaddr.map->segs + i;
+
+		offs = (segdata->p_vaddr & ADDR_ALIGN);
+		_dl_munmap((void*)segdata->addr - offs,
+			segdata->p_memsz + offs);
+	  }
+
+	/*
+	 * _dl_unmap is only called for dlopen()ed libraries, for which
+	 * calling free() is safe, or before we've completed the initial
+	 * relocation, in which case calling free() is probably pointless,
+	 * but still safe.
+	 */
+	_dl_free(loadaddr.map);
+	if (funcdesc_ht)
+		htab_delete(funcdesc_ht);
+}
--- /dev/null
+++ b/ldso/ldso/ubicom32/dl-startup.h
@@ -0,0 +1,233 @@
+/*
+  Copyright (C) 2009 Ubicom, Inc.
+  Copyright (C) 2003 Red Hat, Inc.
+  Contributed by Alexandre Oliva <aoliva@redhat.com>
+
+This file is part of uClibc.
+
+uClibc is free software; you can redistribute it and/or modify it
+under the terms of the GNU Lesser General Public License as
+published by the Free Software Foundation; either version 2.1 of the
+License, or (at your option) any later version.
+
+uClibc is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with uClibc; see the file COPYING.LIB.  If not, write to
+the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
+USA.  */
+
+/* Any assembly language/system dependent hacks needed to setup
+ * boot1.c so it will work as expected and cope with whatever platform
+ * specific wierdness is needed for this architecture.
+
+ * We override the default _dl_boot function, and replace it with a
+ * bit of asm.  Then call the real _dl_boot function, which is now
+ * named _dl_boot2.  */
+
+/* At program start-up, p0 contains a pointer to a
+   elf32_fdpic_loadmap that describes how the executable was loaded
+   into memory.  p1 contains a pointer to the interpreter (our!)
+   loadmap, if there is an interpreter, or 0 if we're being run as an
+   executable.  p2 holds a pointer to the interpreter's dynamic
+   section, if there is an interpreter, or to the executable's dynamic
+   section, otherwise.  If the executable is not dynamic, gr18 is 0.
+
+   We rely on the fact that the linker adds a pointer to the
+   _GLOBAL_OFFSET_TABLE_ as the last ROFIXUP entry, and that
+   __self_reloc returns the relocated pointer to us, so that we can
+   use this value to initialize the PIC register.  */
+
+
+/*
+ *  _dl_boot is the entry point for ldso.
+ *
+ * The kernel leaves the main apps args on the stack (positive offsets), and
+ * communicates the load maps as follows
+ *
+ * - d1 is set to the exec_map_addr (struct elf32_fdpic_loadmap *), which is the
+ *   current state of the mapped application.
+ *
+ * - d2 is set to interp_map_addr (struct elf32_fdpic_loadmap *), which is use
+ *    by ldso to relocate itself.
+ *
+ * - d3 is dynamic_addr which as far as I can tell is the stack pointer.
+ *
+ * - a1 is set to zero and will later be initialised to ldso _dl_fini funcdesc
+ */
+
+__asm__(
+	"	.text							\n\t"
+	"	.global	_start						\n\t"
+	"	.type	_start,@function				\n\t"
+	"_start:\n\t"
+	/*
+	 * Jump to .Lcall storing the location .Lcall in a5
+	 */
+	"	call	a5, .Lcall					\n\t"
+	".Lcall:							\n\t"
+	"	pdec	sp, 256(sp); reserve 64 words for dummy tls block on stack 		\n\t"
+	"	lea.4	12(sp), 256(sp) ; store the argv ptr into the PRENIT slot in tls	\n\t"
+	"	move.4	d14, sp ; Set up tls pointer to point to dummy tls block		\n\t"
+	/*
+	 * Reserve and Push inputs to stack.
+	 * 32 byte  stack layout as follows
+	 * offset	0  exec_map_addr
+	 *		4  interp_map_addr
+	 *		8  dynamic_addr
+	 *		12 not used
+	 *		16 dl_main_funcdesc structure for _dl_boot
+	 *		   (12 bytes sizeof funcdesc_value)
+	 *		28 reserved
+	 *		32  start of &original stack
+	 */
+	"	pdec	sp, 32(sp); reserve stack space			\n\t"
+	"	move.4	0(sp), d1 ; exec_map_addr			\n\t"
+	"	move.4	4(sp), d2 ; interp_map_addr			\n\t"
+	"	move.4	8(sp), d3; dynamic_addr				\n\t"
+
+	/*
+	 * Load linker version of .Lcall in to d0
+	 */
+	"	moveai	a3, #%hi(.Lcall)				\n\t"
+	"	lea.1	d0, %lo(.Lcall)(a3)				\n\t"
+
+	/*
+	 * Determine the offset from loaded .Lcall and put it in d0.
+	 */
+	"	sub.4 d0, a5, d0					\n\t"
+
+	/*
+	 * Load linker version of __ROFIXUP_LIST__ and __ROFIXUP_END__ in to d1
+	 * and d2.
+	 */
+	"	moveai	a3, #%hi(__ROFIXUP_LIST__)			\n\t"
+	"	lea.1	d1, %lo(__ROFIXUP_LIST__)(a3)			\n\t"
+	"	moveai	a3, #%hi(__ROFIXUP_END__)			\n\t"
+	"	lea.1	d2, %lo(__ROFIXUP_END__)(a3)			\n\t"
+	/*
+	 * Use offset determined above to find the loaded versions.
+	 */
+	"	add.4	d1, d1, d0					\n\t"
+	"	add.4	d2, d2, d0					\n\t"
+
+	/*
+	 * Load interp_map_addr into d0, if interp_map_addr is null use
+	 * exec_map_addr.
+	 */
+	"	move.4	d0, 4(sp) ; load interp_map_addr	       	\n\t"
+	"	cmpi	d0, #0						\n\t"
+	"	jmpne.f	1f						\n\t"
+	"	move.4	d0, 0(sp) ; load exec_map_addr			\n\t"
+
+	/*
+	 * call __self_reloc(map, void ***p, void ***e)
+	 * it returns the the GOT in d0.
+	 */
+	"1:	call	a5, __self_reloc ; returns a0 in d0		\n\t"
+	"	move.4	a0, d0 ; set GOT				\n\t"
+	"	move.4	a2, d0 ; save GOT				\n\t"
+
+	/*
+	 * now setup to call
+	 * _dl_start (Elf32_Addr dl_boot_got_pointer,		(d0)
+	 *	struct elf32_fdpic_loadmap *dl_boot_progmap,	(d1)
+	 *	struct elf32_fdpic_loadmap *dl_boot_ldsomap,	(d2)
+	 *	Elf32_Dyn *dl_boot_ldso_dyn_pointer,		(d3)
+	 *	struct funcdesc_value *dl_main_funcdesc,	(d4)
+	 *	unsigned long args				(d5)
+	 *
+	 * NOTE: for dl_main_funcdesc we reserved space on the stack for this
+	 * structure.
+	 */
+	"	move.4	d1, 0(sp)	; d1 = exec_map_addr		\n\t"
+	"	move.4	d2, 4(sp)	; d2 = interp_map_addr		\n\t"
+	"	move.4	d3, 8(sp)	; d3 = dynamic_addr		\n\t"
+	"	lea.1	d4, 16(sp)	; d4 = &dl_main_funcdesc	\n\t"
+	"	lea.4	d5, 288(sp)	; d5 = original stack ptr (args)\n\t"
+	"	call	a5, _dl_start					\n\t"
+
+	/*
+	 * Setup to call the main entry point, starting with passing our FINI
+	 * ptr() to the user in a1 (remember we saved the got in a2)
+	 */
+	"	movei	d15, #%got_funcdesc_lo(_dl_fini)		\n\t"
+	"	move.4	a1, (a2, d15)					\n\t"
+
+	/*
+	 * restore the load map from the kernel.
+	 */
+	"	move.4	d1, 0(sp)	; restore exec_map_addr		\n\t"
+	"	move.4	d2, 4(sp)	; restore interp_map_addr	\n\t"
+	"	move.4	d3, 8(sp)	; restore dynamic_addr		\n\t"
+
+	/*
+	 * _dl_start returned the main apps entry point in dl_main_funcdesc,
+	 * load that information now.
+	 */
+	"	move.4	a5, 16(sp) ; a5 = dl_main_funcdesc.entry_point	\n\t"
+	"	move.4	a0, 20(sp) ; a0 = dl_main_funcdesc.got_value	\n\t"
+	"	lea.4	sp, 288(sp); restore original stack ptr (args)	\n\t"
+	"	calli	a5, 0(a5)					\n\t"
+	"	bkpt	-1; should never get here			\n\t"
+	"	.size	_start, . - _start				\n\t"
+);
+
+#undef DL_START
+#define DL_START(X)   \
+static void  __attribute__ ((used)) \
+_dl_start (Elf32_Addr dl_boot_got_pointer, \
+	   struct elf32_fdpic_loadmap *dl_boot_progmap, \
+	   struct elf32_fdpic_loadmap *dl_boot_ldsomap, \
+	   Elf32_Dyn *dl_boot_ldso_dyn_pointer, \
+	   struct funcdesc_value *dl_main_funcdesc, \
+	   X)
+
+/*
+ * Get a pointer to the argv array.  On many platforms this can be just
+ * the address of the first argument, on other platforms we need to
+ * do something a little more subtle here.
+ */
+#define GET_ARGV(ARGVP, ARGS) ARGVP = (((unsigned long*) ARGS) + 1)
+
+/*
+ * Here is a macro to perform a relocation.  This is only used when
+ * bootstrapping the dynamic loader.  RELP is the relocation that we
+ * are performing, REL is the pointer to the address we are relocating.
+ * SYMBOL is the symbol involved in the relocation, and LOAD is the
+ * load address.
+ */
+#define PERFORM_BOOTSTRAP_RELOC(RELP,REL,SYMBOL,LOAD,SYMTAB) \
+	switch(ELF_R_TYPE((RELP)->r_info)){				\
+	case R_UBICOM32_32:						\
+	  *(REL) += (SYMBOL);						\
+	  break;							\
+	case R_UBICOM32_FUNCDESC_VALUE:					\
+	  {								\
+	    struct funcdesc_value fv = {				\
+	      (void*)((SYMBOL) + *(REL)),				\
+	      (LOAD).got_value						\
+	    };								\
+	    *(struct funcdesc_value volatile *)(REL) = fv;		\
+	    break;							\
+	  }								\
+	default:							\
+	  _dl_exit(1);							\
+	}
+
+/*
+ * Transfer control to the user's application, once the dynamic loader
+ * is done.  We return the address of the function's entry point to
+ * _dl_boot, see boot1_arch.h.
+ */
+#define START()	do {							\
+  struct elf_resolve *exec_mod = _dl_loaded_modules;			\
+  dl_main_funcdesc->entry_point = _dl_elf_main;				\
+  while (exec_mod->libtype != elf_executable)				\
+    exec_mod = exec_mod->next;						\
+  dl_main_funcdesc->got_value = exec_mod->loadaddr.got_value;		\
+  return;								\
+} while (0)
--- /dev/null
+++ b/ldso/ldso/ubicom32/dl-syscalls.h
@@ -0,0 +1 @@
+/* stub for arch-specific syscall issues */
--- /dev/null
+++ b/ldso/ldso/ubicom32/dl-sysdep.h
@@ -0,0 +1,126 @@
+/* Copyright (C) 2012, Qualcomm, Inc.
+ * Based on ../bfin/dl-sysdep.h
+ * Copyright (C) 2003, 2004 Red Hat, Inc.
+ * Contributed by Alexandre Oliva <aoliva@redhat.com>
+ * Copyright (C) 2006-2011 Analog Devices, Inc.
+ * Based on ../i386/dl-sysdep.h
+ *
+ * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+ */
+
+/*
+ * Various assembly language/system dependent  hacks that are required
+ * so that we can minimize the amount of platform specific code.
+ */
+
+/*
+ * Define this if the system uses RELOCA.
+ */
+#undef ELF_USES_RELOCA
+
+/* JMPREL relocs are inside the DT_RELA table.  */
+#define ELF_MACHINE_PLTREL_OVERLAP
+
+#define DL_NO_COPY_RELOCS
+
+/* Here we define the magic numbers that this dynamic loader should accept */
+#define MAGIC1 EM_UBICOM32
+#undef  MAGIC2
+
+/* Used for error messages */
+#define ELF_TARGET "UBICOM32"
+
+/* Need bootstrap relocations */
+#define ARCH_NEEDS_BOOTSTRAP_RELOCS
+
+extern int _dl_linux_resolve(void) __attribute__((__visibility__("hidden")));
+
+/*
+ * TODO: At some point try and make this dynamic based on getpagesize().
+ * For now, we need to set the page size based on the actual kernel page
+ * size that is in use.  This is 4K on (IP3K, IP5K and IP7K) and 16K on
+ * IP8K.
+ */
+#if defined(CONFIG_UC_UBICOM32_V5)
+#define PAGE_ALIGN 0xffffc000
+#define ADDR_ALIGN 0x3fff
+#define OFFS_ALIGN 0x7fffc000
+#else
+#define PAGE_ALIGN 0xfffff000
+#define ADDR_ALIGN 0xfff
+#define OFFS_ALIGN 0x7ffff000
+#endif
+
+struct funcdesc_ht;
+
+/*
+ * This asm does a quick relcation of string S (which is stored in the text
+ * section as thats all we can use
+ */
+#undef SEND_EARLY_STDERR
+#define SEND_EARLY_STDERR(S)						\
+do {									\
+	static const char __attribute__((section(".text"))) __s[] = (S); \
+	const char *__p, *__scratch;					\
+	__asm__ (							\
+	"	call a3, 1f;				\n\t"		\
+	"1:	movei	%0, #%%got_lo(1b)		\n\t"		\
+	"	move.4	%0, (%3, %0)			\n\t"		\
+	"	sub.4	%1, a3, %0;			\n\t"		\
+	"	add.4	%1, %1, %2;			\n\t"		\
+		: "=&d" (__scratch), "=&d" (__p)			\
+		: "d" (__s), "a" (dl_boot_got_pointer)			\
+		: "a3", "cc"						\
+	);								\
+	SEND_STDERR (__p);						\
+	{	int __t;						\
+	  for (__t = 0; __t < 0x1000000; __t++) __asm__ __volatile__ ("");	} \
+} while (0)
+
+/* We only support loading FDPIC independently-relocatable shared
+   libraries.  It probably wouldn't be too hard to support loading
+   shared libraries that require relocation by the same amount, but we
+   don't know that they exist or would be useful, and the dynamic
+   loader code could leak the whole-library map unless we keeping a
+   bit more state for DL_LOADADDR_UNMAP and DL_LIB_UNMAP, so let's
+   keep things simple for now.  */
+#define DL_CHECK_LIB_TYPE(epnt, piclib, _dl_progname, libname) \
+do \
+{ \
+  if (((epnt)->e_flags & EF_UBICOM32_FDPIC) && ! ((epnt)->e_flags & EF_UBICOM32_PIC)) \
+    (piclib) = 2; \
+  else \
+    { \
+      _dl_internal_error_number = LD_ERROR_NOTDYN; \
+      _dl_dprintf(2, "%s: '%s' is not an FDPIC shared library" \
+		  "\n", (_dl_progname), (libname)); \
+      _dl_close(infile); \
+      return NULL; \
+    } \
+\
+} \
+while (0)
+
+#include "../fdpic/dl-sysdep.h"
+
+static __always_inline Elf32_Addr
+elf_machine_load_address (void)
+{
+	/* this is never an issue on Blackfin systems, so screw it */
+	return 0;
+}
+
+static __always_inline void
+elf_machine_relative (DL_LOADADDR_TYPE load_off, const Elf32_Addr rel_addr,
+		      Elf32_Word relative_count)
+{
+#if 0
+	 Elf32_Rel * rpnt = (void *) rel_addr;
+	--rpnt;
+	do {
+		Elf32_Addr *const reloc_addr = (void *) (load_off + (++rpnt)->r_offset);
+
+		*reloc_addr = DL_RELOC_ADDR (load_off, *reloc_addr);
+	} while (--relative_count);
+#endif
+}
--- /dev/null
+++ b/ldso/ldso/ubicom32/elfinterp.c
@@ -0,0 +1,377 @@
+/* Ubicom32 ELF shared library support
+   Copyright (C) 2012 Qualcomm, Inc.
+   Based on ../bfin/elfinterp.c, so:
+   Blackfin ELF shared library loader suppport
+   Copyright (C) 2003, 2004 Red Hat, Inc.
+   Contributed by Alexandre Oliva <aoliva@redhat.com>
+   Lots of code copied from ../i386/elfinterp.c, so:
+   Copyright (c) 1994-2000 Eric Youngdale, Peter MacDonald,
+				David Engel, Hongjiu Lu and Mitch D'Souza
+   Copyright (C) 2001-2002, Erik Andersen
+   All rights reserved.
+
+This file is part of uClibc.
+
+uClibc is free software; you can redistribute it and/or modify it
+under the terms of the GNU Lesser General Public License as
+published by the Free Software Foundation; either version 2.1 of the
+License, or (at your option) any later version.
+
+uClibc is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with uClibc; see the file COPYING.LIB.  If not, write to
+the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
+USA.  */
+
+#include <sys/cdefs.h>	    /* __attribute_used__ */
+
+/* Program to load an ELF binary on a linux system, and run it.
+   References to symbols in sharable libraries can be resolved by either
+   an ELF sharable library or a linux style of shared library. */
+
+/* Disclaimer:  I have never seen any AT&T source code for SVr4, nor have
+   I ever taken any courses on internals.  This program was developed using
+   information available through the book "UNIX SYSTEM V RELEASE 4,
+   Programmers guide: Ansi C and Programming Support Tools", which did
+   a more than adequate job of explaining everything required to get this
+   working. */
+
+/*
+ * _dl_ubicom32_resolve_pending is actually a function, it is used to
+ * deal with multiple threads resolving the same function at the same
+ * time.  While a resolution is being done the _dl_linux_resolve ptr in
+ * the plt is replaced with _dl_ubicom32_resolve_pending The chances that
+ * it ever gets called probably 1 in a million.
+ */
+extern int _dl_ubicom32_resolve_pending __attribute__((__visibility__("hidden")));
+
+ __attribute__((__visibility__("hidden")))
+struct funcdesc_value volatile *
+_dl_linux_resolver (struct elf_resolve *tpnt, int reloc_entry)
+{
+	int reloc_type;
+	ELF_RELOC *this_reloc;
+	char *strtab;
+	ElfW(Sym) *symtab;
+	int symtab_index;
+	char *rel_addr;
+	char *new_addr;
+	struct funcdesc_value funcval;
+	struct funcdesc_value volatile *got_entry;
+	char *symname;
+	struct symbol_ref sym_ref;
+
+	rel_addr = (char *)tpnt->dynamic_info[DT_JMPREL];
+
+	this_reloc = (ELF_RELOC *)(intptr_t)(rel_addr + reloc_entry);
+	reloc_type = ELF_R_TYPE(this_reloc->r_info);
+	symtab_index = ELF_R_SYM(this_reloc->r_info);
+
+	symtab = (ElfW(Sym) *) tpnt->dynamic_info[DT_SYMTAB];
+	strtab = (char *) tpnt->dynamic_info[DT_STRTAB];
+	sym_ref.sym = &symtab[symtab_index];
+	sym_ref.tpnt = NULL;
+	symname= strtab + symtab[symtab_index].st_name;
+
+	if (reloc_type != R_UBICOM32_FUNCDESC_VALUE) {
+		_dl_dprintf(2, "%s: Incorrect relocation type in jump relocations\n",
+			    _dl_progname);
+		_dl_exit(1);
+	}
+
+	/* Address of GOT entry fix up */
+	got_entry = (struct funcdesc_value *) DL_RELOC_ADDR(tpnt->loadaddr, this_reloc->r_offset);
+
+	/* Get the address to be used to fill in the GOT entry.  */
+	new_addr = _dl_find_hash(symname, &_dl_loaded_modules->symbol_scope, NULL, 0, &sym_ref);
+	if (!new_addr) {
+		new_addr = _dl_find_hash(symname, NULL, NULL, 0, &sym_ref);
+		if (!new_addr) {
+			_dl_dprintf(2, "_dl_linux_resolver: %s: can't resolve symbol '%s'\n",
+				    _dl_progname, symname);
+			_dl_exit(1);
+		}
+	}
+
+	funcval.entry_point = new_addr;
+	funcval.got_value = sym_ref.tpnt->loadaddr.got_value;
+
+#if defined (__SUPPORT_LD_DEBUG__)
+	if (_dl_debug_bindings) {
+		_dl_dprintf(_dl_debug_file, "\nresolve function: %s", symname);
+		if (_dl_debug_detail)
+			_dl_dprintf(_dl_debug_file,
+				    "\n\tpatched (%x,%x) ==> (%x,%x) @ %x\n",
+				    got_entry->entry_point, got_entry->got_value,
+				    funcval.entry_point, funcval.got_value,
+				    got_entry);
+	}
+	if (1 || !_dl_debug_nofixups) {
+		got_entry->entry_point = ((void *)&_dl_ubicom32_resolve_pending);
+		got_entry->got_value = funcval.got_value;
+		got_entry->entry_point = funcval.entry_point;
+	}
+#else
+	/*
+	 * initially set the entry point to resolve pending before starting
+	 * the update. This has the effect of putting all other requests in a
+	 * holding pattern until the resolution is completed.
+	 */
+	got_entry->entry_point = ((void*)&_dl_ubicom32_resolve_pending);
+	got_entry->got_value = funcval.got_value;
+	got_entry->entry_point = funcval.entry_point;
+#endif
+
+	return got_entry;
+}
+
+static int
+_dl_parse(struct elf_resolve *tpnt, struct r_scope_elem *scope,
+	  unsigned long rel_addr, unsigned long rel_size,
+	  int (*reloc_fnc) (struct elf_resolve *tpnt, struct r_scope_elem *scope,
+			    ELF_RELOC *rpnt, ElfW(Sym) *symtab, char *strtab))
+{
+	unsigned int i;
+	char *strtab;
+	ElfW(Sym) *symtab;
+	ELF_RELOC *rpnt;
+	int symtab_index;
+
+	/* Now parse the relocation information */
+	rpnt = (ELF_RELOC *) rel_addr;
+	rel_size = rel_size / sizeof(ELF_RELOC);
+
+	symtab = (ElfW(Sym) *) tpnt->dynamic_info[DT_SYMTAB];
+	strtab = (char *) tpnt->dynamic_info[DT_STRTAB];
+
+	for (i = 0; i < rel_size; i++, rpnt++) {
+		int res;
+
+		symtab_index = ELF_R_SYM(rpnt->r_info);
+		debug_sym(symtab,strtab,symtab_index);
+		debug_reloc(symtab,strtab,rpnt);
+
+		res = reloc_fnc (tpnt, scope, rpnt, symtab, strtab);
+
+		if (res==0) continue;
+
+		_dl_dprintf(2, "\n%s: ",_dl_progname);
+
+		if (symtab_index)
+			_dl_dprintf(2, "symbol '%s': ", strtab + symtab[symtab_index].st_name);
+
+		if (res <0) {
+			int reloc_type = ELF_R_TYPE(rpnt->r_info);
+#if defined (__SUPPORT_LD_DEBUG__)
+			_dl_dprintf(2, "can't handle reloc type %s\n ", _dl_reltypes(reloc_type));
+#else
+			_dl_dprintf(2, "can't handle reloc type %x\n", reloc_type);
+#endif
+			_dl_exit(-res);
+		} else if (res >0) {
+			_dl_dprintf(2, "can't resolve symbol\n");
+			return res;
+		}
+	  }
+	  return 0;
+}
+
+static int
+_dl_do_reloc (struct elf_resolve *tpnt,struct r_scope_elem *scope,
+	      ELF_RELOC *rpnt, ElfW(Sym) *symtab, char *strtab)
+{
+	int reloc_type;
+	int symtab_index;
+	char *symname;
+	unsigned long reloc_value = 0, *reloc_addr;
+	struct { unsigned long v; } __attribute__((__packed__))
+					    *reloc_addr_packed;
+	unsigned long symbol_addr;
+	struct elf_resolve *symbol_tpnt;
+	struct funcdesc_value funcval;
+#if defined (__SUPPORT_LD_DEBUG__)
+	unsigned long old_val;
+#endif
+	struct symbol_ref sym_ref;
+
+	reloc_addr   = (unsigned long *) DL_RELOC_ADDR(tpnt->loadaddr, rpnt->r_offset);
+	__asm__ ("" : "=r" (reloc_addr_packed) : "0" (reloc_addr));
+	reloc_type   = ELF_R_TYPE(rpnt->r_info);
+	symtab_index = ELF_R_SYM(rpnt->r_info);
+	symbol_addr  = 0;
+	sym_ref.sym =  &symtab[symtab_index];
+	sym_ref.tpnt =  NULL;
+	symname      = strtab + symtab[symtab_index].st_name;
+
+	if (ELF_ST_BIND (symtab[symtab_index].st_info) == STB_LOCAL) {
+		symbol_addr = (unsigned long) DL_RELOC_ADDR(tpnt->loadaddr, symtab[symtab_index].st_value);
+		symbol_tpnt = tpnt;
+	} else {
+
+		symbol_addr = (unsigned long)
+		  _dl_find_hash(symname, scope, NULL, 0, &sym_ref);
+
+		/*
+		 * We want to allow undefined references to weak symbols - this might
+		 * have been intentional.  We should not be linking local symbols
+		 * here, so all bases should be covered.
+		 */
+
+		if (!symbol_addr && ELF_ST_BIND(symtab[symtab_index].st_info) != STB_WEAK) {
+			_dl_dprintf (2, "_dl_do_reloc: %s: can't resolve symbol '%s'\n",
+				     _dl_progname, symname);
+			_dl_exit (1);
+		}
+		if (_dl_trace_prelink) {
+			_dl_debug_lookup (symname, tpnt, &symtab[symtab_index],
+				&sym_ref, elf_machine_type_class(reloc_type));
+		}
+		symbol_tpnt = sym_ref.tpnt;
+	}
+
+#if defined (__SUPPORT_LD_DEBUG__)
+	if (_dl_debug_reloc && _dl_debug_detail)
+	  {
+	    if ((long)reloc_addr_packed & 3)
+	      old_val = reloc_addr_packed->v;
+	    else
+	      old_val = *reloc_addr;
+	  }
+	else
+	  old_val = 0;
+#endif
+	switch (reloc_type) {
+	case R_UBICOM32_NONE:
+		break;
+	case R_UBICOM32_32:
+		if ((long)reloc_addr_packed & 3)
+			reloc_value = reloc_addr_packed->v += symbol_addr;
+		else
+			reloc_value = *reloc_addr += symbol_addr;
+		break;
+	case R_UBICOM32_FUNCDESC_VALUE:
+		funcval.entry_point = (void*)symbol_addr;
+		/* The addend of FUNCDESC_VALUE
+		   relocations referencing global
+		   symbols must be ignored, because it
+		   may hold the address of a lazy PLT
+		   entry.  */
+		if (ELF_ST_BIND(symtab[symtab_index].st_info) == STB_LOCAL)
+			funcval.entry_point += *reloc_addr;
+		reloc_value = (unsigned long)funcval.entry_point;
+		if (symbol_addr)
+			funcval.got_value
+				= symbol_tpnt->loadaddr.got_value;
+		else
+			funcval.got_value = 0;
+
+/// XXX this is my best guess as to what I should be doing, but I'm
+/// putting a break-point here so I can inspect the first time this is
+/// used.
+		__asm__ (
+		"	move.4 4(%0), 4(%1)		\n\t"
+		"	move.4 0(%0), 0(%1)		\n\t" /* Must to entry_point last */
+			:
+			: "a" (reloc_addr), "a" (&funcval)
+			: "memory" );
+		break;
+	case R_UBICOM32_FUNCDESC:
+		if ((long)reloc_addr_packed & 3)
+			reloc_value = reloc_addr_packed->v;
+		else
+			reloc_value = *reloc_addr;
+		if (symbol_addr)
+			reloc_value = (unsigned long)_dl_funcdesc_for
+				((char *)symbol_addr + reloc_value,
+				 symbol_tpnt->loadaddr.got_value);
+		else
+			reloc_value = 0;
+		if ((long)reloc_addr_packed & 3)
+			reloc_addr_packed->v = reloc_value;
+		else
+			*reloc_addr = reloc_value;
+		break;
+	default:
+		return -1;
+	}
+#if defined (__SUPPORT_LD_DEBUG__)
+	if (_dl_debug_reloc && _dl_debug_detail) {
+		_dl_dprintf(_dl_debug_file, "\tpatched: %x ==> %x @ %x", old_val, reloc_value, reloc_addr);
+		switch (reloc_type) {
+		case R_UBICOM32_FUNCDESC_VALUE:
+			_dl_dprintf(_dl_debug_file, " got %x", ((struct funcdesc_value *)reloc_value)->got_value);
+			break;
+		case R_UBICOM32_FUNCDESC:
+			if (! reloc_value)
+				break;
+			_dl_dprintf(_dl_debug_file, " funcdesc (%x,%x)",
+				    ((struct funcdesc_value *)reloc_value)->entry_point,
+				    ((struct funcdesc_value *)reloc_value)->got_value);
+			break;
+		}
+	}
+#endif
+
+	return 0;
+}
+
+static int
+_dl_do_lazy_reloc (struct elf_resolve *tpnt,
+		   struct r_scope_elem *scope __attribute__((unused)),
+		   ELF_RELOC *rpnt, ElfW(Sym) *symtab __attribute__((unused)),
+		   char *strtab __attribute__((unused)))
+{
+	int reloc_type;
+	struct funcdesc_value volatile *reloc_addr;
+	struct funcdesc_value funcval;
+#if defined (__SUPPORT_LD_DEBUG__)
+	unsigned long old_val;
+#endif
+
+	reloc_addr = (struct funcdesc_value *) DL_RELOC_ADDR(tpnt->loadaddr, rpnt->r_offset);
+	reloc_type = ELF_R_TYPE(rpnt->r_info);
+
+#if defined (__SUPPORT_LD_DEBUG__)
+	old_val = (unsigned long)reloc_addr->entry_point;
+#endif
+		switch (reloc_type) {
+			case R_UBICOM32_NONE:
+				break;
+			case R_UBICOM32_FUNCDESC_VALUE:
+				funcval = *reloc_addr;
+				funcval.entry_point = (void*)DL_RELOC_ADDR(tpnt->loadaddr, funcval.entry_point);
+				funcval.got_value = tpnt->loadaddr.got_value;
+				*reloc_addr = funcval;
+				break;
+			default:
+				return -1;
+		}
+#if defined (__SUPPORT_LD_DEBUG__)
+	if (_dl_debug_reloc && _dl_debug_detail)
+		_dl_dprintf(_dl_debug_file, "\tpatched: %x ==> %x @ %x\n", old_val, reloc_addr->entry_point, reloc_addr);
+#endif
+	return 0;
+
+}
+
+void
+_dl_parse_lazy_relocation_information
+(struct dyn_elf *rpnt, unsigned long rel_addr, unsigned long rel_size)
+{
+  _dl_parse(rpnt->dyn, NULL, rel_addr, rel_size, _dl_do_lazy_reloc);
+}
+
+int
+_dl_parse_relocation_information
+(struct dyn_elf *rpnt, struct r_scope_elem *scope, unsigned long rel_addr, unsigned long rel_size)
+{
+  return _dl_parse(rpnt->dyn, scope, rel_addr, rel_size, _dl_do_reloc);
+}
+
+#ifndef IS_IN_libdl
+# include "../../libc/sysdeps/linux/ubicom32/crtreloc.c"
+#endif
--- /dev/null
+++ b/ldso/ldso/ubicom32/resolve.S
@@ -0,0 +1,161 @@
+     /* Copyright (C) 2003 Red Hat, Inc.
+	Contributed by Alexandre Oliva <aoliva@redhat.com>
+
+	Copyright (C) 2009 Ubicom Inc.
+	Ported to Ubicom32 by Ubicom Inc.
+
+This file is part of uClibc.
+
+uClibc is free software; you can redistribute it and/or modify it
+under the terms of the GNU Lesser General Public License as
+published by the Free Software Foundation; either version 2.1 of the
+License, or (at your option) any later version.
+
+uClibc is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with uClibc; see the file COPYING.LIB.  If not, write to
+the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
+USA.  */
+
+
+/*
+ * The function below is tail-called by resolver stubs when a lazily-bound *
+ * function is called.  It must preserve all registers that could * be used to
+ * pass arguments to the actual function.
+ *
+ * On entry to the function d0-d13 contain parameters to the actual function of
+ * interest
+ *
+ * a5 contains the return address
+ * a0 is pointing to the GOT table for the original function
+ *  (a0) _dl_linux_resolve
+ * 4(a0) GOT for _dl_linux_resolve
+ * 8(a0) is pointer to "structure elf_resolve" of the module where the call
+ *	originated from
+ *
+ * a3 is pointing to the function descriptor in the GOT table, and 8(a3) the
+ * resolver lookup information.
+ *
+ * _dl_linux_resolve calls _dl_linux_resolver passing it pointer to
+ * struct elf_resolve and the relocation entry.
+ *
+ * _dl_linux_resolver() figures out where the jump symbol is _really_ supposed
+ * to have jumped to and returns that to us. Once we have that, we prepare to
+ * tail-call the actual function, clean up after ourselves, restoring the
+ * original arguments, then jump to the fixed up address.
+ */
+
+#if 0
+	/*
+	 * Here is what the linker will use for the PLT.
+	 */
+sample_PLT_functionX:	/* (at entry a0 contains GOT for this library)  */
+	movei	d15, # -%lo(got_funcdescX) ; load offset for GOT
+	lea.4	a3, (a0, d15)	; a4 is now the function descriptor
+	move.4	a4, 0(a3)	; get entry_point
+	move.4	a0, 4(a3)	; set new GOT
+
+	/*
+	 * jump to resovled function OR PLT_trampoline Nat had some code here
+	 * that uses the stack instead of a3 to reduces hazards.
+	 */
+	calli	a4, 0(a4)
+
+
+sample_PLT_trampoline:
+	/*
+	 * find the old got by undoing what was done above. An alternative
+	 * could have been to ‘save’ the old got in say d14 but that would add 1
+	 * instruction to every PLT and there is only 1 PLT trampoline per library.
+	 */
+	ret	(a0)		; jump to _dl_linux_resolve
+#endif
+
+	.text
+	.p2align 4
+
+	.hidden	_dl_linux_resolve
+	.global	_dl_linux_resolve
+	.type	_dl_linux_resolve,@function
+_dl_linux_resolve:
+	/* Preserve arguments and return address  */
+	move.4	-4(sp)++, d0
+	move.4	-4(sp)++, d1
+	move.4	-4(sp)++, d2
+	move.4	-4(sp)++, d3
+	move.4	-4(sp)++, d4
+	move.4	-4(sp)++, d5
+	move.4	-4(sp)++, d6
+	move.4	-4(sp)++, d7
+	move.4	-4(sp)++, d8
+	move.4	-4(sp)++, d9
+	move.4	-4(sp)++, d10
+	move.4	-4(sp)++, d11
+	move.4	-4(sp)++, d12
+	move.4	-4(sp)++, d13
+	move.4	-4(sp)++, a5
+
+	/* Prepare to call _dl_linux_resolver.  */
+	move.4 d0, 8(a0)	; reference to elf_resolve
+	/* Not aligned for space reasons.  */
+	move.4 d1, mac_hi 	; reference to GOT table entry which
+				; contains the relocation information.
+
+	move.4 a0, 4(a0) ; switch to GOT for _dl_linux_resolve
+	call	a5, _dl_linux_resolver;
+
+	/* Move aside return value that contains the FUNCDESC_VALUE.  */
+	;P3 = R0;
+	move.4 a3, d0;
+
+	/* Restore arguments.  */
+	move.4	a5, (sp)4++
+	move.4	d13, (sp)4++
+	move.4	d12, (sp)4++
+	move.4	d11, (sp)4++
+	move.4	d10, (sp)4++
+	move.4	d9, (sp)4++
+	move.4	d8, (sp)4++
+	move.4	d7, (sp)4++
+	move.4	d6, (sp)4++
+	move.4	d5, (sp)4++
+	move.4	d4, (sp)4++
+	move.4	d3, (sp)4++
+	move.4	d2, (sp)4++
+	move.4	d1, (sp)4++
+	move.4	d0, (sp)4++
+
+	/* Now jump to the actual function.  */
+	/* a3 contains func_desc resolution */
+	move.4 a4, 0(a3)	; address of function X
+	move.4 a0, 4(a3)	; switch to GOT for function X
+	calli  a4, 0(a4)	; call through a4, a5 remains
+
+	.size	_dl_linux_resolve, . - _dl_linux_resolve
+
+	.hidden	_dl_ubicom32_resolve_pending
+	.global	_dl_ubicom32_resolve_pending
+	.type	_dl_ubicom32_resolve_pending,@function
+
+_dl_ubicom32_resolve_pending:
+	/*
+	 * A special function that is used to ensure thread saftly when the fd
+	 * for a particular resolution is being updated.
+	 *
+	 * At entry, a3 must point to the FD.  While the FD is being updated the
+	 * entry_point will continue to point to _dl_ubicom32_resolve_pending so
+	 * we will effectively spin until the resolver update is complete.
+	 */
+
+	move.4	a4, 0(a3)	; get entry_point
+	move.4	a0, 4(a3)	; set new GOT
+
+	/*
+	 * jump to resovled function or back to _dl_ubicom32_resolve_pending.
+	 */
+	calli	a4, 0(a4)
+	.size	_dl_ubicom32_resolve_pending, . - _dl_ubicom32_resolve_pending
--- a/libc/misc/Makefile.in
+++ b/libc/misc/Makefile.in
@@ -12,7 +12,9 @@ include $(top_srcdir)libc/misc/assert/Ma
 include $(top_srcdir)libc/misc/ctype/Makefile.in
 include $(top_srcdir)libc/misc/dirent/Makefile.in
 include $(top_srcdir)libc/misc/error/Makefile.in
+ifneq ($(ARCH_HAS_NO_LDSO),y)
 include $(top_srcdir)libc/misc/elf/Makefile.in
+endif
 include $(top_srcdir)libc/misc/file/Makefile.in
 include $(top_srcdir)libc/misc/fnmatch/Makefile.in
 include $(top_srcdir)libc/misc/ftw/Makefile.in
--- a/libc/misc/elf/dl-iterate-phdr.c
+++ b/libc/misc/elf/dl-iterate-phdr.c
@@ -14,7 +14,7 @@
 
 #include <link.h>
 #include <ldso.h>
-
+#include <memory.h>
 /* we want this in libc but nowhere else */
 #ifdef __USE_GNU
 
--- a/libc/stdlib/malloc/malloc.c
+++ b/libc/stdlib/malloc/malloc.c
@@ -23,7 +23,7 @@
 
 /* The malloc heap.  We provide a bit of initial static space so that
    programs can do a little mallocing without mmaping in more space.  */
-HEAP_DECLARE_STATIC_FREE_AREA (initial_fa, 256);
+HEAP_DECLARE_STATIC_FREE_AREA (initial_fa, 32768);
 struct heap_free_area *__malloc_heap = HEAP_INIT_WITH_FA (initial_fa);
 #ifdef HEAP_USE_LOCKING
 malloc_mutex_t __malloc_heap_lock = PTHREAD_MUTEX_INITIALIZER;
--- /dev/null
+++ b/libc/string/ubicom32/Makefile
@@ -0,0 +1,13 @@
+# Makefile for uClibc
+#
+# Copyright (C) 2000-2005 Erik Andersen <andersen@uclibc.org>
+#
+# Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+#
+
+top_srcdir:=../../../
+top_builddir:=../../../
+all: objs
+include $(top_builddir)Rules.mak
+include ../Makefile.in
+include $(top_srcdir)Makerules
--- /dev/null
+++ b/libc/string/ubicom32/memcpy.c
@@ -0,0 +1,152 @@
+/* Copy memory to memory until the specified number of bytes
+   has been copied.  Overlap is NOT handled correctly.
+   Copyright (C) 1991, 1997, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Torbjorn Granlund (tege@sics.se).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <string.h>
+
+typedef unsigned long addr_t;
+
+libc_hidden_proto(memcpy)
+
+void *memcpy (void *dest, const void *src, size_t n)
+{
+	void *dest_ret = dest;
+	void *aligned_start;
+
+	if (likely((((addr_t)dest ^ (addr_t)src) & 3) == 0) && likely(n > 6)) {
+		size_t m;
+		n -= (4 - (addr_t)dest) & 0x03;
+		m = n >> 2;
+		__asm__ volatile (
+		"	sub.4		d15, #0, %2		\n\t"	// set up for jump table
+		"	and.4		d15, #(32-1), d15	\n\t"	// d15 = (-m) & (32 - 1)
+		"	lsl.4		d15, d15, #1		\n\t"	// We need 2 instructions per word
+		"	call		%4, .+4			\n\t"
+		"	lea.4		%4, (%4,d15)		\n\t"	// 18 inst from here to 1f
+
+		"	bfextu		d15, %0, #2		\n\t"	// d15 = (dest & 3)
+		"	jmpne.w.f	100f			\n\t"
+		"	calli		%4, 4*18(%4)		\n\t"	// 4-byte alignment
+
+		"100:	cmpi		d15, #2			\n\t"
+		"	jmpne.s.f	101f			\n\t"
+		"	move.2		(%0)2++, (%1)2++	\n\t"
+		"	calli		%4, 4*18(%4)		\n\t"	// 2-byte alignment
+
+		"101:	move.1		(%0)1++, (%1)1++	\n\t"
+		"	jmpgt.s.f	102f			\n\t"	// 3-byte alignment
+		"	move.2		(%0)2++, (%1)2++	\n\t"	// 1-byte alignment
+		"102:	calli		%4, 4*18(%4)		\n\t"
+
+		"200:	cmpi		%3, #2			\n\t"
+		"	jmplt.s.f	201f			\n\t"
+		"	move.2		(%0)2++, (%1)2++	\n\t"
+		"	jmpeq.s.t	2f			\n\t"
+		"201:	move.1		(%0)1++, (%1)1++	\n\t"
+		"	jmpt.w.t	2f			\n\t"
+
+		"1:	.rept		25			\n\t"
+		"	movea		(%0)4++, (%1)4++	\n\t"
+		"	nop					\n\t"	// nop to avoid overfilling the write buffer!
+		"	.endr					\n\t"
+		"	.rept		7			\n\t"
+		"	move.4		(%0)4++, (%1)4++	\n\t"
+		"	nop					\n\t"	// nop to avoid overfilling the write buffer!
+		"	.endr					\n\t"
+		"	add.4		%2, #-32, %2		\n\t"
+		"	jmpgt.w.f	1b			\n\t"
+
+		"	and.4		%3, #3, %3		\n\t"	// check n
+		"	jmpne.w.f	200b			\n\t"
+		"2:						\n\t"
+			: "+a" (dest), "+a" (src), "+d" (m), "+d" (n), "=a" (aligned_start)
+			:
+			: "d15", "memory", "cc"
+		);
+
+		return dest_ret;
+	}
+
+	if (likely((((addr_t)dest ^ (addr_t)src) & 1) == 0) && likely(n > 2)) {
+		size_t m;
+		n -= (addr_t)dest & 0x01;
+		m = n >> 1;
+		__asm__ volatile (
+		"	sub.4		d15, #0, %2		\n\t"	// set up for jump table
+		"	and.4		d15, #(32-1), d15	\n\t"	// d15 = (-m) & (32 - 1)
+		"	lsl.4		d15, d15, #1		\n\t"	// We need 2 instructions per word
+		"	call		%4, .+4			\n\t"
+		"	lea.4		%4, (%4,d15)		\n\t"	// 8 inst from here to 1f
+
+		"	btst		%0, #0			\n\t"	// check bit 0
+		"	jmpne.w.f	100f			\n\t"
+		"	calli		%4, 4*8(%4)		\n\t"	// 4-byte alignment
+
+		"100:	move.1		(%0)1++, (%1)1++	\n\t"
+		"	calli		%4, 4*8(%4)		\n\t"
+
+		"200:	move.1		(%0)1++, (%1)1++	\n\t"
+		"	jmpt.w.t	2f			\n\t"
+
+		"1:	.rept		32			\n\t"
+		"	move.2		(%0)2++, (%1)2++	\n\t"
+		"	nop					\n\t"	// nop to avoid overfilling the write buffer!
+		"	.endr					\n\t"
+		"	add.4		%2, #-32, %2		\n\t"
+		"	jmpgt.w.f	1b			\n\t"
+
+		"	and.4		%3, #1, %3		\n\t"	// check n
+		"	jmpne.w.f	200b			\n\t"
+		"2:						\n\t"
+
+			: "+a" (dest), "+a" (src), "+d" (m), "+d" (n), "=a"(aligned_start)
+			:
+			: "d15", "memory", "cc"
+		);
+
+		return dest_ret;
+	}
+
+	__asm__ volatile (
+	"	sub.4		d15, #0, %2		\n\t"
+	"	jmpeq.w.f	2f			\n\t"
+	"	and.4		d15, #(16-1), d15	\n\t"	// d15 = (-n) & (16 - 1)
+	"	lsl.4		d15, d15, #1		\n\t"	// We need 2 instructions per word
+	"	call		%3, .+4			\n\t"
+	"	lea.4		%3, (%3,d15)		\n\t"	// 2 inst from here to 1f
+	"	calli		%3, 8(%3)		\n\t"
+
+	"1:	.rept		16			\n\t"
+	"	move.1		(%0)1++, (%1)1++	\n\t"
+	"	nop					\n\t"	// nop to avoid overfilling the write buffer!
+	"	.endr					\n\t"
+	"	add.4		%2, #-16, %2		\n\t"
+	"	jmpgt.w.f	1b			\n\t"
+	"2:						\n\t"
+
+		: "+a" (dest), "+a" (src), "+d" (n), "=a" (aligned_start)
+		:
+		: "d15", "memory", "cc"
+	);
+
+	return dest_ret;
+}
+libc_hidden_weak(memcpy)
+
--- /dev/null
+++ b/libc/string/ubicom32/memset.c
@@ -0,0 +1,103 @@
+/* Copyright (C) 1991, 1997, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <string.h>
+
+typedef unsigned long addr_t;
+
+libc_hidden_proto(memset)
+void *memset (void *s, int c, size_t n)
+{
+	void *s_ret = s;
+	void *aligned_start;
+
+	if (likely(n > 6)) {
+		size_t m;
+		n -= (4 - (addr_t)s) & 0x03;
+		m = n >> 2;
+		__asm__ volatile (
+		"	sub.4		d15, #0, %2		\n\t"	// set up for jump table
+		"	and.4		d15, #(32-1), d15	\n\t"	// d15 = (-m) & (32 - 1)
+		"	shmrg.1		%1, %1, %1		\n\t"
+		"	shmrg.2		%1, %1, %1		\n\t"	// %1 = (c<<24)|(c<<16)|(c<<8)|c
+		"	call		%4, .+4			\n\t"
+		"	lea.4		%4, (%4,d15)		\n\t"	// 18 inst from here to 1f
+
+		"	bfextu		d15, %0, #2		\n\t"	// d15 = (s & 3)
+		"	jmpne.w.f	100f			\n\t"
+		"	calli		%4, 4*18(%4)		\n\t"	// 4-byte alignment
+
+		"100:	cmpi		d15, #2			\n\t"
+		"	jmpne.s.f	101f			\n\t"
+		"	move.2		(%0)2++, %1		\n\t"
+		"	calli		%4, 4*18(%4)		\n\t"	// 2-byte alignment
+
+		"101:	move.1		(%0)1++, %1		\n\t"
+		"	jmpgt.s.f	102f			\n\t"	// 3-byte alignment
+		"	move.2		(%0)2++, %1		\n\t"	// 1-byte alignment
+		"102:	calli		%4, 4*18(%4)		\n\t"
+
+		"200:	cmpi		%3, #2			\n\t"
+		"	jmplt.s.f	201f			\n\t"
+		"	move.2		(%0)2++, %1		\n\t"
+		"	jmpeq.s.t	2f			\n\t"
+		"201:	move.1		(%0)1++, %1		\n\t"
+		"	jmpt.w.t	2f			\n\t"
+
+		"1:	.rept		25			\n\t"
+		"	movea		(%0)4++, %1		\n\t"
+		"	.endr					\n\t"
+		"	.rept		7			\n\t"
+		"	move.4		(%0)4++, %1		\n\t"
+		"	.endr					\n\t"
+		"	add.4		%2, #-32, %2		\n\t"
+		"	jmpgt.w.f	1b			\n\t"
+
+		"	and.4		%3, #3, %3		\n\t"	// test bit 1 of n
+		"	jmpne.w.f	200b			\n\t"
+		"2:						\n\t"
+			: "+a" (s), "+d" (c), "+d" (m), "+d" (n), "=a" (aligned_start)
+			:
+			: "d15", "memory", "cc"
+		);
+
+		return s_ret;
+	}
+
+	__asm__ volatile (
+	"	sub.4		d15, #0, %2		\n\t"
+	"	jmpeq.w.f	2f			\n\t"
+	"	and.4		d15, #(8-1), d15	\n\t"	// d15 = (-%2) & (16 - 1)
+	"	call		%3, .+4			\n\t"
+	"	lea.4		%3, (%3,d15)		\n\t"	// 2 inst from here to 1f
+	"	calli		%3, 8(%3)		\n\t"
+
+	"1:	.rept		8			\n\t"
+	"	move.1		(%0)1++, %1		\n\t"
+	"	.endr					\n\t"
+	"2:						\n\t"
+
+		: "+a" (s), "+d" (c), "+d" (n), "=a"(aligned_start)
+		:
+		: "d15", "memory", "cc"
+	);
+
+	return s_ret;
+}
+libc_hidden_weak(memset)
+
--- /dev/null
+++ b/libc/sysdeps/linux/ubicom32/Makefile
@@ -0,0 +1,13 @@
+# Makefile for uClibc
+#
+# Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+#
+# Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+#
+
+top_srcdir=../../../../
+top_builddir=../../../../
+all: objs
+include $(top_builddir)Rules.mak
+include Makefile.arch
+include $(top_srcdir)Makerules
--- /dev/null
+++ b/libc/sysdeps/linux/ubicom32/Makefile.arch
@@ -0,0 +1,19 @@
+# Makefile for uClibc
+#
+# Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+#
+# Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+#
+
+CSRC := \
+	syscall.c __syscall_error.c
+
+ifeq ($(ARCH_USE_MMU),y)
+      CSRC += brk.c
+endif
+ 
+SSRC := \
+	clone.S setjmp.S vfork.S
+
+ARCH_CFLAGS := $(CPU_CFLAGS-y)
+include $(top_srcdir)libc/sysdeps/linux/Makefile.commonarch
--- /dev/null
+++ b/libc/sysdeps/linux/ubicom32/__syscall_error.c
@@ -0,0 +1,11 @@
+#include <errno.h>
+#include <features.h>
+
+/* This routine is jumped to by some of the syscall handlers, to stash
+ * an error number into errno.  */
+int __syscall_error(int err_no) attribute_hidden;
+int __syscall_error(int err_no)
+{
+	__set_errno(err_no);
+	return -1;
+}
--- /dev/null
+++ b/libc/sysdeps/linux/ubicom32/bits/elf-fdpic.h
@@ -0,0 +1,115 @@
+/* Copyright 2003, 2004 Free Software Foundation, Inc.
+This file is part of the GNU C Library.
+
+The GNU C Library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public License as
+published by the Free Software Foundation; either version 2.1 of the
+License, or (at your option) any later version.
+
+In addition to the permissions in the GNU Lesser General Public
+License, the Free Software Foundation gives you unlimited
+permission to link the compiled version of this file with other
+programs, and to distribute those programs without any restriction
+coming from the use of this file.  (The GNU Lesser General Public
+License restrictions do apply in other respects; for example, they
+cover modification of the file, and distribution when not linked
+into another program.)
+
+The GNU C Library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with the GNU C Library; see the file COPYING.LIB.  If
+not, write to the Free Software Foundation, Inc., 675 Mass Ave,
+Cambridge, MA 02139, USA.  */
+
+#ifndef _BITS_ELF_FDPIC_H
+#define _BITS_ELF_FDPIC_H
+
+/* These data structures are described in the FDPIC ABI extension.
+   The kernel passes a process a memory map, such that for every LOAD
+   segment there is an elf32_fdpic_loadseg entry.  A pointer to an
+   elf32_fdpic_loadmap is passed in d8 at start-up, and a pointer to
+   an additional such map is passed in d9 for the interpreter, when
+   there is one.  */
+
+#include <elf.h>
+
+/* This data structure represents a PT_LOAD segment.  */
+struct elf32_fdpic_loadseg
+{
+  /* Core address to which the segment is mapped.  */
+  Elf32_Addr addr;
+  /* VMA recorded in the program header.  */
+  Elf32_Addr p_vaddr;
+  /* Size of this segment in memory.  */
+  Elf32_Word p_memsz;
+};
+
+struct elf32_fdpic_loadmap {
+  /* Protocol version number, must be zero.  */
+  Elf32_Half version;
+  /* Number of segments in this map.  */
+  Elf32_Half nsegs;
+  /* The actual memory map.  */
+  struct elf32_fdpic_loadseg segs[/*nsegs*/];
+};
+
+struct elf32_fdpic_loadaddr {
+  struct elf32_fdpic_loadmap *map;
+  void *got_value;
+};
+
+/* Map a pointer's VMA to its corresponding address according to the
+   load map.  */
+static __always_inline void *
+__reloc_pointer (void *p,
+		 const struct elf32_fdpic_loadmap *map)
+{
+  int c;
+
+#if 0
+  if (map->version != 0)
+    /* Crash.  */
+    ((void(*)())0)();
+#endif
+
+  /* No special provision is made for NULL.  We don't want NULL
+     addresses to go through relocation, so they shouldn't be in
+     .rofixup sections, and, if they're present in dynamic
+     relocations, they shall be mapped to the NULL address without
+     undergoing relocations.  */
+
+  for (c = 0;
+       /* Take advantage of the fact that the loadmap is ordered by
+	  virtual addresses.  In general there will only be 2 entries,
+	  so it's not profitable to do a binary search.  */
+       c < map->nsegs && p >= (void*)map->segs[c].p_vaddr;
+       c++)
+    {
+      /* This should be computed as part of the pointer comparison
+	 above, but we want to use the carry in the comparison, so we
+	 can't convert it to an integer type beforehand.  */
+      unsigned long offset = p - (void*)map->segs[c].p_vaddr;
+      /* We only check for one-past-the-end for the last segment,
+	 assumed to be the data segment, because other cases are
+	 ambiguous in the absence of padding between segments, and
+	 rofixup already serves as padding between text and data.
+	 Unfortunately, unless we special-case the last segment, we
+	 fail to relocate the _end symbol.  */
+      if (offset < map->segs[c].p_memsz
+	  || (offset == map->segs[c].p_memsz && c + 1 == map->nsegs))
+	return (char*)map->segs[c].addr + offset;
+    }
+
+  /* We might want to crash instead.  */
+  return (void*)-1;
+}
+
+# define __RELOC_POINTER(ptr, loadaddr) \
+  (__reloc_pointer ((void*)(ptr), \
+		    (loadaddr).map))
+
+#endif /* _BITS_ELF_FDPIC_H */
--- /dev/null
+++ b/libc/sysdeps/linux/ubicom32/bits/endian.h
@@ -0,0 +1,7 @@
+/* Ubicom32 is big-endian.  */
+
+#ifndef _ENDIAN_H
+# error "Never use <bits/endian.h> directly; include <endian.h> instead."
+#endif
+
+#define __BYTE_ORDER __BIG_ENDIAN
--- /dev/null
+++ b/libc/sysdeps/linux/ubicom32/bits/fcntl.h
@@ -0,0 +1,236 @@
+/* O_*, F_*, FD_* bit values for Linux.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_FCNTL_H
+# error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
+#endif
+
+
+#include <sys/types.h>
+#ifdef __USE_GNU
+# include <bits/uio.h>
+#endif
+
+/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
+   located on an ext2 file system */
+#define O_ACCMODE	   0003
+#define O_RDONLY	     00
+#define O_WRONLY	     01
+#define O_RDWR		     02
+#define O_CREAT		   0100	/* not fcntl */
+#define O_EXCL		   0200	/* not fcntl */
+#define O_NOCTTY	   0400	/* not fcntl */
+#define O_TRUNC		  01000	/* not fcntl */
+#define O_APPEND	  02000
+#define O_NONBLOCK	  04000
+#define O_NDELAY	O_NONBLOCK
+#define O_SYNC		 010000
+#define O_FSYNC		 O_SYNC
+#define O_ASYNC		 020000
+
+#ifdef __USE_GNU
+# define O_DIRECTORY	 040000	/* Must be a directory.	 */
+# define O_NOFOLLOW	0100000	/* Do not follow links.	 */
+# define O_DIRECT	0200000	/* Direct disk access.	*/
+# define O_NOATIME    01000000 /* Do not set atime.  */
+# define O_CLOEXEC	02000000 /* set close_on_exec */
+# define O_STREAMING	04000000/* streaming access */
+#endif
+
+/* For now Linux has synchronisity options for data and read operations.
+   We define the symbols here but let them do the same as O_SYNC since
+   this is a superset.	*/
+#if defined __USE_POSIX199309 || defined __USE_UNIX98
+# define O_DSYNC	O_SYNC	/* Synchronize data.  */
+# define O_RSYNC	O_SYNC	/* Synchronize read operations.	 */
+#endif
+
+#ifdef __USE_LARGEFILE64
+# define O_LARGEFILE	0400000
+#endif
+
+/* Values for the second argument to `fcntl'.  */
+#define F_DUPFD		0	/* Duplicate file descriptor.  */
+#define F_GETFD		1	/* Get file descriptor flags.  */
+#define F_SETFD		2	/* Set file descriptor flags.  */
+#define F_GETFL		3	/* Get file status flags.  */
+#define F_SETFL		4	/* Set file status flags.  */
+#ifndef __USE_FILE_OFFSET64
+# define F_GETLK	5	/* Get record locking info.  */
+# define F_SETLK	6	/* Set record locking info (non-blocking).  */
+# define F_SETLKW	7	/* Set record locking info (blocking).	*/
+#else
+# define F_GETLK	F_GETLK64  /* Get record locking info.	*/
+# define F_SETLK	F_SETLK64  /* Set record locking info (non-blocking).*/
+# define F_SETLKW	F_SETLKW64 /* Set record locking info (blocking).  */
+#endif
+#define F_GETLK64	12	/* Get record locking info.  */
+#define F_SETLK64	13	/* Set record locking info (non-blocking).  */
+#define F_SETLKW64	14	/* Set record locking info (blocking).	*/
+
+#if defined __USE_BSD || defined __USE_XOPEN2K
+# define F_SETOWN	8	/* Get owner of socket (receiver of SIGIO).  */
+# define F_GETOWN	9	/* Set owner of socket (receiver of SIGIO).  */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETSIG	10	/* Set number of signal to be sent.  */
+# define F_GETSIG	11	/* Get number of signal to be sent.  */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETLEASE	1024	/* Set a lease.	 */
+# define F_GETLEASE	1025	/* Enquire what lease is active.  */
+# define F_NOTIFY	1026	/* Request notfications on a directory.	 */
+#endif
+
+/* For F_[GET|SET]FL.  */
+#define FD_CLOEXEC	1	/* actually anything with low bit set goes */
+
+/* For posix fcntl() and `l_type' field of a `struct flock' for lockf().  */
+#define F_RDLCK		0	/* Read lock.  */
+#define F_WRLCK		1	/* Write lock.	*/
+#define F_UNLCK		2	/* Remove lock.	 */
+
+/* For old implementation of bsd flock().  */
+#define F_EXLCK		4	/* or 3 */
+#define F_SHLCK		8	/* or 4 */
+
+#ifdef __USE_BSD
+/* Operations for bsd flock(), also used by the kernel implementation.	*/
+# define LOCK_SH	1	/* shared lock */
+# define LOCK_EX	2	/* exclusive lock */
+# define LOCK_NB	4	/* or'd with one of the above to prevent
+				   blocking */
+# define LOCK_UN	8	/* remove lock */
+#endif
+
+#ifdef __USE_GNU
+# define LOCK_MAND	32	/* This is a mandatory flock:	*/
+# define LOCK_READ	64	/* ... which allows concurrent read operations.	 */
+# define LOCK_WRITE	128	/* ... which allows concurrent write operations.  */
+# define LOCK_RW	192	/* ... Which allows concurrent read & write operations.	 */
+#endif
+
+#ifdef __USE_GNU
+/* Types of directory notifications that may be requested with F_NOTIFY.  */
+# define DN_ACCESS	0x00000001	/* File accessed.  */
+# define DN_MODIFY	0x00000002	/* File modified.  */
+# define DN_CREATE	0x00000004	/* File created.  */
+# define DN_DELETE	0x00000008	/* File removed.  */
+# define DN_RENAME	0x00000010	/* File renamed.  */
+# define DN_ATTRIB	0x00000020	/* File changed attibutes.  */
+# define DN_MULTISHOT	0x80000000	/* Don't remove notifier.  */
+#endif
+
+struct flock
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+#ifndef __USE_FILE_OFFSET64
+    __off_t l_start;	/* Offset where the lock begins.  */
+    __off_t l_len;	/* Size of the locked area; zero means until EOF.  */
+#else
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+#endif
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+
+#ifdef __USE_LARGEFILE64
+struct flock64
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+#endif
+
+/* Define some more compatibility macros to be backward compatible with
+   BSD systems which did not managed to hide these kernel macros.  */
+#ifdef	__USE_BSD
+# define FAPPEND	O_APPEND
+# define FFSYNC		O_FSYNC
+# define FASYNC		O_ASYNC
+# define FNONBLOCK	O_NONBLOCK
+# define FNDELAY	O_NDELAY
+#endif /* Use BSD.  */
+
+/* Advise to `posix_fadvise'.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_FADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_FADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_FADV_SEQUENTIAL	2 /* Expect sequential page references.	 */
+# define POSIX_FADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_FADV_DONTNEED	4 /* Don't need these pages.  */
+# define POSIX_FADV_NOREUSE	5 /* Data will be accessed once.  */
+#endif
+
+
+#if defined __USE_GNU && defined __UCLIBC_LINUX_SPECIFIC__
+/* Flags for SYNC_FILE_RANGE.  */
+# define SYNC_FILE_RANGE_WAIT_BEFORE	1 /* Wait upon writeout of all pages
+					     in the range before performing the
+					     write.  */
+# define SYNC_FILE_RANGE_WRITE		2 /* Initiate writeout of all those
+					     dirty pages in the range which are
+					     not presently under writeback.  */
+# define SYNC_FILE_RANGE_WAIT_AFTER	4 /* Wait upon writeout of all pages in
+					     the range after performing the
+					     write.  */
+
+/* Flags for SPLICE and VMSPLICE.  */
+# define SPLICE_F_MOVE		1	/* Move pages instead of copying.  */
+# define SPLICE_F_NONBLOCK	2	/* Don't block on the pipe splicing
+					   (but we may still block on the fd
+					   we splice from/to).  */
+# define SPLICE_F_MORE		4	/* Expect more data.  */
+# define SPLICE_F_GIFT		8	/* Pages passed in are a gift.  */
+#endif
+
+__BEGIN_DECLS
+
+#if defined __USE_GNU && defined __UCLIBC_LINUX_SPECIFIC__
+
+/* Provide kernel hint to read ahead.  */
+extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
+    __THROW;
+
+/* Selective file content synch'ing.  */
+extern int sync_file_range (int __fd, __off64_t __from, __off64_t __to,
+			    unsigned int __flags);
+
+/* Splice address range into a pipe.  */
+extern ssize_t vmsplice (int __fdout, const struct iovec *__iov,
+			 size_t __count, unsigned int __flags);
+
+/* Splice two files together.  */
+extern ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
+		       __off64_t *__offout, size_t __len,
+		       unsigned int __flags);
+
+/* In-kernel implementation of tee for pipe buffers.  */
+extern ssize_t tee (int __fdin, int __fdout, size_t __len,
+		    unsigned int __flags);
+
+#endif
+
+__END_DECLS
--- /dev/null
+++ b/libc/sysdeps/linux/ubicom32/bits/kernel_stat.h
@@ -0,0 +1,52 @@
+#ifndef _BITS_STAT_STRUCT_H
+#define _BITS_STAT_STRUCT_H
+
+#ifndef _LIBC
+#error bits/kernel_stat.h is for internal uClibc use only!
+#endif
+
+/* This file provides whatever this particular arch's kernel thinks 
+ * struct kernel_stat should look like...  It turns out each arch has a 
+ * different opinion on the subject... */
+
+struct kernel_stat {
+	unsigned short st_dev;
+	unsigned short __pad1;
+	unsigned long st_ino;
+	unsigned short st_mode;
+	unsigned short st_nlink;
+	unsigned short st_uid;
+	unsigned short st_gid;
+	unsigned short st_rdev;
+	unsigned short __pad2;
+	unsigned long  st_size;
+	unsigned long  st_blksize;
+	unsigned long  st_blocks;
+	struct timespec st_atim;
+	struct timespec st_mtim;
+	struct timespec st_ctim;
+	unsigned long  __unused4;
+	unsigned long  __unused5;
+};
+
+struct kernel_stat64 {
+	unsigned long long	st_dev;
+	unsigned int		__pad1;
+#define _HAVE_STAT64___ST_INO
+	unsigned long	__st_ino;
+	unsigned int	st_mode;
+	unsigned int	st_nlink;
+	unsigned long	st_uid;
+	unsigned long	st_gid;
+	unsigned long long	st_rdev;
+	unsigned int	__pad2;
+	long long	st_size;
+	unsigned long	st_blksize;
+	unsigned long long	st_blocks;	/* Number 512-byte blocks allocated. */
+	struct timespec st_atim;
+	struct timespec st_mtim;
+	struct timespec st_ctim;
+	unsigned long long	st_ino;
+};
+
+#endif	/*  _BITS_STAT_STRUCT_H */
--- /dev/null
+++ b/libc/sysdeps/linux/ubicom32/bits/kernel_types.h
@@ -0,0 +1,44 @@
+/* Note that we use the exact same include guard #define names
+ * as asm/posix_types.h.  This will avoid gratuitous conflicts 
+ * with the posix_types.h kernel header, and will ensure that 
+ * our private content, and not the kernel header, will win.
+ *  -Erik
+ */
+#ifndef __ARCH_UBICOM32_POSIX_TYPES_H
+#define __ARCH_UBICOM32_POSIX_TYPES_H
+
+typedef unsigned long	__kernel_dev_t;
+typedef unsigned long	__kernel_ino_t;
+typedef unsigned short	__kernel_mode_t;
+typedef unsigned short	__kernel_nlink_t;
+typedef long		__kernel_off_t;
+typedef int		__kernel_pid_t;
+typedef unsigned short	__kernel_ipc_pid_t;
+typedef unsigned short	__kernel_uid_t;
+typedef unsigned short	__kernel_gid_t;
+typedef unsigned int	__kernel_size_t;
+typedef int		__kernel_ssize_t;
+typedef int		__kernel_ptrdiff_t;
+typedef long		__kernel_time_t;
+typedef long		__kernel_suseconds_t;
+typedef long		__kernel_clock_t;
+typedef int		__kernel_daddr_t;
+typedef char *		__kernel_caddr_t;
+typedef unsigned short	__kernel_uid16_t;
+typedef unsigned short	__kernel_gid16_t;
+typedef unsigned int	__kernel_uid32_t;
+typedef unsigned int	__kernel_gid32_t;
+typedef unsigned short	__kernel_old_uid_t;
+typedef unsigned short	__kernel_old_gid_t;
+typedef unsigned short	__kernel_old_dev_t;
+typedef long long	__kernel_loff_t;
+
+typedef struct {
+#ifdef __USE_ALL
+	int val[2];
+#else
+	int __val[2];
+#endif
+} __kernel_fsid_t;
+
+#endif /* __ARCH_UBICOM32_POSIX_TYPES_H */
--- /dev/null
+++ b/libc/sysdeps/linux/ubicom32/bits/mman.h
@@ -0,0 +1,104 @@
+/* Definitions for POSIX memory map interface.  Linux/m68k version.
+   Copyright (C) 1997, 2000, 2003, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MMAN_H
+# error "Never use <bits/mman.h> directly; include <sys/mman.h> instead."
+#endif
+
+/* The following definitions basically come from the kernel headers.
+   But the kernel header is not namespace clean.  */
+
+
+/* Protections are chosen from these bits, OR'd together.  The
+   implementation does not necessarily support PROT_EXEC or PROT_WRITE
+   without PROT_READ.  The only guarantees are that no writing will be
+   allowed without PROT_WRITE and no access will be allowed for PROT_NONE. */
+
+#define PROT_READ	0x1		/* Page can be read.  */
+#define PROT_WRITE	0x2		/* Page can be written.  */
+#define PROT_EXEC	0x4		/* Page can be executed.  */
+#define PROT_NONE	0x0		/* Page can not be accessed.  */
+#define PROT_GROWSDOWN	0x01000000	/* Extend change to start of
+					   growsdown vma (mprotect only).  */
+#define PROT_GROWSUP	0x02000000	/* Extend change to start of
+					   growsup vma (mprotect only).  */
+
+/* Sharing types (must choose one and only one of these).  */
+#define MAP_SHARED	0x01		/* Share changes.  */
+#define MAP_PRIVATE	0x02		/* Changes are private.  */
+#ifdef __USE_MISC
+# define MAP_TYPE	0x0f		/* Mask for type of mapping.  */
+#endif
+
+/* Other flags.  */
+#define MAP_FIXED	0x10		/* Interpret addr exactly.  */
+#ifdef __USE_MISC
+# define MAP_FILE	0
+# define MAP_ANONYMOUS	0x20		/* Don't use a file.  */
+# define MAP_ANON	MAP_ANONYMOUS
+#endif
+
+/* These are Linux-specific.  */
+#ifdef __USE_MISC
+# define MAP_GROWSDOWN	0x00100		/* Stack-like segment.  */
+# define MAP_DENYWRITE	0x00800		/* ETXTBSY */
+# define MAP_EXECUTABLE	0x01000		/* Mark it as an executable.  */
+# define MAP_LOCKED	0x02000		/* Lock the mapping.  */
+# define MAP_NORESERVE	0x04000		/* Don't check for reservations.  */
+# define MAP_POPULATE	0x08000		/* Populate (prefault) pagetables.  */
+# define MAP_NONBLOCK	0x10000		/* Do not block on IO.  */
+# define MAP_UNINITIALIZE 0x4000000     /* For anonymous mmap, memory could
+					   be uninitialized. */
+#endif
+
+/* Flags to `msync'.  */
+#define MS_ASYNC	1		/* Sync memory asynchronously.  */
+#define MS_SYNC		4		/* Synchronous memory sync.  */
+#define MS_INVALIDATE	2		/* Invalidate the caches.  */
+
+/* Flags for `mlockall'.  */
+#define MCL_CURRENT	1		/* Lock all currently mapped pages.  */
+#define MCL_FUTURE	2		/* Lock all additions to address
+					   space.  */
+
+/* Flags for `mremap'.  */
+#ifdef __USE_GNU
+# define MREMAP_MAYMOVE	1
+# define MREMAP_FIXED	2
+#endif
+
+/* Advice to `madvise'.  */
+#ifdef __USE_BSD
+# define MADV_NORMAL	 0	/* No further special treatment.  */
+# define MADV_RANDOM	 1	/* Expect random page references.  */
+# define MADV_SEQUENTIAL 2	/* Expect sequential page references.  */
+# define MADV_WILLNEED	 3	/* Will need these pages.  */
+# define MADV_DONTNEED	 4	/* Don't need these pages.  */
+# define MADV_DONTFORK	 10	/* Do not inherit across fork.  */
+# define MADV_DOFORK	 11	/* Do inherit across fork.  */
+#endif
+
+/* The POSIX people had to invent similar names for the same things.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_MADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_MADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_MADV_SEQUENTIAL	2 /* Expect sequential page references.  */
+# define POSIX_MADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_MADV_DONTNEED	4 /* Don't need these pages.  */
+#endif
--- /dev/null
+++ b/libc/sysdeps/linux/ubicom32/bits/setjmp.h
@@ -0,0 +1,52 @@
+/* Define the machine-dependent type `jmp_buf'.  Ubicom32 version.
+   Copyright (C) 1992,93,95,97,2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_SETJMP_H
+#define _BITS_SETJMP_H	1
+
+#if !defined _SETJMP_H && !defined _PTHREAD_H
+# error "Never include <bits/setjmp.h> directly; use <setjmp.h> instead."
+#endif
+
+#ifndef	_ASM
+/* 
+ * This is the structure where we are going to save D10-D13, A0, A1, A2, A5, A6 and SP(A7).
+ * A5 is the return address. Call to setjmp will save these. Call to longjmp will return
+ * Control to the address in A5.
+ */
+typedef struct setjmp_save_struct {
+	unsigned long  d10;		/* D10 */
+	unsigned long  d11;		/* D11 */
+	unsigned long  d12;		/* D12 */
+	unsigned long  d13;		/* D13 */
+	unsigned long  a1;		/* A1  */
+	unsigned long  a2;		/* A2  */
+	unsigned long  a5;		/* A5 return address. */
+	unsigned long  a6;		/* A6 */
+	unsigned long  sp;		/* A7 stack pointer. */
+} __jmp_buf[1];
+
+#endif
+
+/* Test if longjmp to JMPBUF would unwind the frame
+   containing a local variable at ADDRESS.  */
+#define _JMPBUF_UNWINDS(jmpbuf, address) \
+  ((void *) (address) < (void*)(jmpbuf)->sp)
+
+#endif	/* bits/setjmp.h */
--- /dev/null
+++ b/libc/sysdeps/linux/ubicom32/bits/stackinfo.h
@@ -0,0 +1,28 @@
+/* Copyright (C) 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* This file contains a bit of information about the stack allocation
+   of the processor.  */
+
+#ifndef _STACKINFO_H
+#define _STACKINFO_H	1
+
+/* On Ubicom32 the stack grows down.  */
+#define _STACK_GROWS_DOWN	1
+
+#endif	/* stackinfo.h */
--- /dev/null
+++ b/libc/sysdeps/linux/ubicom32/bits/syscalls.h
@@ -0,0 +1,150 @@
+#ifndef _BITS_SYSCALLS_H
+#define _BITS_SYSCALLS_H
+#ifndef _SYSCALL_H
+# error "Never use <bits/syscalls.h> directly; include <sys/syscall.h> instead."
+#endif
+
+/* m68k headers does stupid stuff with __NR_iopl / __NR_vm86:
+ * #define __NR_iopl   not supported
+ * #define __NR_vm86   not supported
+ */
+#undef __NR_iopl
+#undef __NR_vm86
+
+#include <config/autoconf.h>
+
+#if defined(__ASSEMBLER__)
+/*
+ * Define assembly macros to hide syscall call differences
+ */
+#if (UBICOM32_ARCH_VERSION >= 3) && (UBICOM32_ARCH_VERSION <= 4)
+.macro __syscall
+	moveai a5, #%hi(0x3FFC0030)
+	calli a5, 0x30(a5)
+.endm
+#elif (UBICOM32_ARCH_VERSION == 5)
+.macro __syscall
+	syscall a5
+.endm
+#else
+#error "UInknown Ubicom32 processor"
+#endif
+
+#else // C code
+
+#include <errno.h>
+
+/* Ubicom32 Linux takes system call arguments in registers:
+
+	syscall number	%d8
+	arg 1		%d0
+	arg 2		%d1
+	arg 3		%d2
+	arg 4		%d3
+	arg 5		%d4
+	arg 6		%d5
+*/
+
+#define __loadargs_0(name, dummy)					\
+	d8 = name
+
+#define __loadargs_1(name, __arg1)					\
+	__loadargs_0(name, 0);						\
+	d0_retval = (long int)(__arg1)
+
+#define __loadargs_2(name, __arg1, __arg2)				\
+	__loadargs_1(name, __arg1);					\
+	d1 = (long int)(__arg2)
+
+#define __loadargs_3(name, __arg1, __arg2, __arg3)			\
+	__loadargs_2(name, __arg1, __arg2);				\
+	d2 = (long int)(__arg3)
+
+#define __loadargs_4(name, __arg1, __arg2, __arg3, __arg4)		\
+	__loadargs_3(name, __arg1, __arg2, __arg3);			\
+	d3 = (long int)(__arg4)
+
+#define __loadargs_5(name, __arg1, __arg2, __arg3, __arg4, __arg5)	\
+	__loadargs_4(name, __arg1, __arg2, __arg3, __arg4);		\
+	d4 = (long int)(__arg5)
+
+#define __loadargs_6(name, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6) \
+	__loadargs_5(name, __arg1, __arg2, __arg3, __arg4, __arg5);	\
+	d5 = (long int)(__arg6)
+
+
+/*
+ * macro __INTERNAL_SYSCALL_BODY_NCS()
+ *
+ * Loads the nr args into the d0...d5 registers and set d8 to the syscall
+ * number.  calls to 0x404000010 which is the syscall entry point, being
+ * care-full to mark all the other registers as being clobbered (per default abi).
+ *
+ * The result from the syscall will be stored in d0_retval.
+ */
+#if (UBICOM32_ARCH_VERSION >= 3) && (UBICOM32_ARCH_VERSION <= 4)
+#define __INTERNAL_SYSCALL_BODY_NCS(name, nr, args...)			\
+	long int d0_copy;						\
+	register long int d0_retval __asm__ ("d0");			\
+	register long int d1 __asm__ ("d1");				\
+	register long int d2 __asm__ ("d2");				\
+	register long int d3 __asm__ ("d3");				\
+	register long int d4 __asm__ ("d4");				\
+	register long int d5 __asm__ ("d5");				\
+	register long int d8 __asm__ ("d8");				\
+	__loadargs_##nr (name, args);					\
+	__asm__ __volatile__ (						\
+	"	moveai a5, #%%hi(0x3FFC0030)\n\t"			\
+	"	calli a5, 0x30(a5)\n\t"					\
+		: "+r" (d0_retval), "+r" (d1), "+r" (d2), "+r" (d3),	\
+		  "+r" (d4), "+r" (d5),  "+r" (d8) :			\
+		: "cc", "memory",					\
+		  "acc0_lo", "acc0_hi", "acc1_lo", "acc1_hi",		\
+		  "source3",						\
+		  "a0", "a3", "a4", "a5",				\
+		  "d6", "d7", "d9", "d14", "d15"			\
+	);
+#elif (UBICOM32_ARCH_VERSION == 5)
+#define __INTERNAL_SYSCALL_BODY_NCS(name, nr, args...)			\
+	long int d0_copy;						\
+	register long int d0_retval __asm__ ("d0");			\
+	register long int d1 __asm__ ("d1");				\
+	register long int d2 __asm__ ("d2");				\
+	register long int d3 __asm__ ("d3");				\
+	register long int d4 __asm__ ("d4");				\
+	register long int d5 __asm__ ("d5");				\
+	register long int d8 __asm__ ("d8");				\
+	__loadargs_##nr (name, args);					\
+	__asm__ __volatile__ (						\
+	"	syscall a5	\n\t"					\
+		: "+r" (d0_retval), "+r" (d1), "+r" (d2), "+r" (d3),	\
+		  "+r" (d4), "+r" (d5),  "+r" (d8) :			\
+		: "cc", "memory",					\
+		  "acc0_lo", "acc0_hi", "acc1_lo", "acc1_hi",		\
+		  "source3",						\
+		  "a0", "a3", "a4", "a5",				\
+		  "d6", "d7", "d9", "d14", "d15"			\
+	);
+#else
+#error "Unknown Ubicom32 Processor"
+#endif
+
+#define INTERNAL_SYSCALL_NCS(name, err, nr, args...)			\
+	({								\
+		__INTERNAL_SYSCALL_BODY_NCS(name, nr, args);		\
+		d0_retval;						\
+	})
+
+#define INLINE_SYSCALL_NCS(name, nr, args...)				\
+	({								\
+		__INTERNAL_SYSCALL_BODY_NCS(name, nr, args);		\
+		if (unlikely((unsigned long)(d0_retval) >= (unsigned long)(-125))) { \
+			d0_copy = d0_retval;				\
+			__set_errno (-d0_copy);				\
+			d0_retval = -1L;				\
+		}							\
+		d0_retval;						\
+	})
+
+#endif /* __ASSEMBLER__ */
+#endif /* _BITS_SYSCALLS_H */
--- /dev/null
+++ b/libc/sysdeps/linux/ubicom32/bits/uClibc_arch_features.h
@@ -0,0 +1,45 @@
+/*
+ * Track misc arch-specific features that aren't config options
+ */
+
+#ifndef _BITS_UCLIBC_ARCH_FEATURES_H
+#define _BITS_UCLIBC_ARCH_FEATURES_H
+
+/* instruction used when calling abort() to kill yourself */
+/*#define __UCLIBC_ABORT_INSTRUCTION__ "asm instruction"*/
+#undef __UCLIBC_ABORT_INSTRUCTION__
+
+/* can your target use syscall6() for mmap ? */
+#undef __UCLIBC_MMAP_HAS_6_ARGS__
+
+/* does your target use syscall4() for truncate64 ? (32bit arches only) */
+#undef __UCLIBC_TRUNCATE64_HAS_4_ARGS__
+
+/* does your target have a broken create_module() ? */
+#undef __UCLIBC_BROKEN_CREATE_MODULE__
+
+/* does your target have to worry about older [gs]etrlimit() ? */
+#undef __UCLIBC_HANDLE_OLDER_RLIMIT__
+
+/* does your target prefix all symbols with an _ ? */
+#define __UCLIBC_NO_UNDERSCORES__
+
+/* does your target have an asm .set ? */
+#define __UCLIBC_HAVE_ASM_SET_DIRECTIVE__
+
+/* define if target doesn't like .global */
+#undef __UCLIBC_ASM_GLOBAL_DIRECTIVE__
+
+/* define if target supports .weak */
+#define __UCLIBC_HAVE_ASM_WEAK_DIRECTIVE__
+
+/* define if target supports .weakext */
+#undef __UCLIBC_HAVE_ASM_WEAKEXT_DIRECTIVE__
+
+/* needed probably only for ppc64 */
+#undef __UCLIBC_HAVE_ASM_GLOBAL_DOT_NAME__
+
+/* define if target supports IEEE signed zero floats */
+#define __UCLIBC_HAVE_SIGNED_ZERO__
+
+#endif /* _BITS_UCLIBC_ARCH_FEATURES_H */
--- /dev/null
+++ b/libc/sysdeps/linux/ubicom32/bits/wordsize.h
@@ -0,0 +1,19 @@
+/* Copyright (C) 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define __WORDSIZE	32
--- /dev/null
+++ b/libc/sysdeps/linux/ubicom32/clone.S
@@ -0,0 +1,80 @@
+/*
+ * libc/sysdeps/linux/ubicom32/clone.S -- 'clone' syscall for linux/ubicom32
+ *
+ * Copyright (C) 2009, Ubicom, Inc.
+ *
+ * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+ */
+
+#include <sys/syscall.h>
+
+	.global __syscall_error
+
+/* int _clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg); */
+	.text
+	.type   clone,@function
+	.global clone
+clone:
+	/* Sanity check arguments.  */
+	sub.4	#0, #0, d0	/* Test if fn is zero. */
+	jmpeq.f .Leinval	/* arg bad */
+	sub.4	#0, #0, d1	/* Test if child_stack is zero. */
+	jmpeq.f	.Leinval	/* arg bad */
+
+	move.4	-4(sp)++, a5	/* push a5 to our stack */
+	move.4	-4(sp)++, a1	/* push a1 */
+	move.4	a1, d0		/* save fn in a1 */
+	/*
+	 * The syscall clone is clone(int flags, void *child_stack) so we set
+	 * that up now
+	 */
+	move.4	d0, d2		/* Move flags to d0 */
+				/* child stack is already in d1 */
+
+	/* Do Clone syscall */
+	movei	d8, #__NR_clone
+	__syscall
+
+	/* Clone Complete */
+	cmpi	d0, #0		/* Test if d0 is less than zero. If it is we
+				 * return the error */
+	jmpeq.f	.Lchild_thread	/* If return is 0 we are in the clone, jump to
+				 * thread start */
+	move.4	a1, (sp)4++	/* pop a1 from stack */
+	move.4	a5, (sp)4++	/* pop a5 from stack */
+	jmplt.f	.Lerror		/* If return is less than we had an error */
+	ret	a5		/* d0 is pid */
+
+	/* Invalid Value */
+.Leinval:
+	movei   d0, #-22	/* EINVAL */
+
+	/* Call syscall Error (it will return through a5) */
+.Lerror:
+	sub.4	d0, #0, d0	/* d0 = -d0 */
+#if defined(__UBICOM32_FDPIC__)
+	call	a3, __syscall_error
+#else
+	moveai	a3, #%hi(__syscall_error)
+	calli	a3, %lo(__syscall_error)(a3)
+#endif
+
+	/* Child Thread Start */
+.Lchild_thread:
+	move.4	d0, d3		/* copy 'arg' to d0 (this is because ubicom32
+				   syscall doesn't clobber d0-d5,d8 */
+#if defined(__UBICOM32_FDPIC__)
+	/* a5 actually contains a function descriptor for fdpic */
+	move.4	a0, 4(a1)	/* set GOT for this function */
+	move.4	a5, 0(a1)	/* get address of entry point */
+	calli	a5, 0(a5)
+#else
+	calli	a5, 0(a1)
+#endif
+	movei	d8, #__NR_exit
+	__syscall
+
+	.size clone, . - clone
+	.global __GI_clone
+	.hidden __GI_clone
+	.set __GI_clone,clone
--- /dev/null
+++ b/libc/sysdeps/linux/ubicom32/crt1.S
@@ -0,0 +1,193 @@
+/* Startup code compliant to the default ubicom32 ABI.
+   Copyright (C) 2009, Ubicom, Inc.
+   Copyright (C) 1996, 1997, 1998, 2001, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <features.h>
+
+/* This is the canonical entry point, usually the first thing in the text
+   segment.  The SVR4/ubicom32 FD-PIC ABI says that when the entry point
+   runs, most registers' values are unspecified, except for:
+
+   The kernel leaves the main apps args on the stack (positive offsets), and
+   communicates the load maps as follows
+
+	d1 is set to the exec_map_addr (struct elf32_fdpic_loadmap *), which is the
+	current state of the mapped application.
+
+	d2 is set to interp_map_addr (struct elf32_fdpic_loadmap *), which is use
+	by ldso to relocate itself (not used when not using ld.so)
+
+	d3 is dynamic_addr which as far as I can tell is the stack pointer.
+
+	a1 is set to zero and will later be initialised to ldso _dl_fini
+	funcdesc if ld.so is involved.  When set, will contains a function
+	pointer to be registered with `atexit'.  This is how the dynamic linker
+	arranges to have DT_FINI functions called for shared libraries that have
+	been loaded before this code runs.
+
+   The stack contains the arguments and environment:
+		0(%sp)			argc
+		4(%sp)			argv[0]
+		...
+		(4*argc)(%sp)		NULL
+		(4*(argc+1))(%sp)	envp[0]
+		...
+					NULL
+
+   The uclinux FLAT format conventions are different.  d1, d2, d3 and a1 are not
+   defined on entry and the stack is laid out as follows:
+
+		0(%sp)			argc
+		4(%sp)			argv
+		8(%sp)			envp
+*/
+
+
+	.text
+	.type   main,@function
+	.type	_init,%function
+	.type	_fini,%function
+#ifndef __UCLIBC_CTOR_DTOR__
+	.weak	_init
+	.weak	_fini
+#endif
+	.globl	_start
+	.global __uClibc_main;
+	.type	__uClibc_main,@function;
+	.type	_start,@function
+_start:
+
+#if defined(__UBICOM32_FDPIC__) && !defined(L_Scrt1)
+	/* d1 contains a pointer to the program's load map.  */
+	call	a3, .Lcall;
+.Lcall:
+	move.4	d0, d1 ; load exec_map_addr
+	moveai	a4, #%hi(.Lcall)
+	lea.1	d15, %lo(.Lcall)(a4)
+	sub.4	d15, a3, d15	;  difference between .Lcall and actual address of .Lcall
+	moveai	a3, #%hi(__ROFIXUP_LIST__)
+	lea.1	d1, %lo(__ROFIXUP_LIST__)(a3)
+	moveai	a3, #%hi(__ROFIXUP_END__)
+	lea.1	d2, %lo(__ROFIXUP_END__)(a3)
+	add.4	d1, d1, d15
+	add.4	d2, d2, d15
+	call	a5, __self_reloc	; returns GOT in d0
+	move.4	a0, d0	; set GOT
+#endif
+
+/*
+	all this is setup to make the following call.
+
+	void __uClibc_main(
+		d0 - int (*main)(int, char **, char **),
+		d1 - int argc, (d1)
+		d2 - char **argv,
+		d3 - void (*app_init)(void),
+		d4 - void (*app_fini)(void),
+		d5 - void (*rtld_fini)(void),
+		d6 - void *stack_end
+	);
+ */
+
+	/*
+	 * Load pointer to main into d0
+	 */
+#ifdef __UBICOM32_FDPIC__
+	movei	d0, #%got_funcdesc_lo(main)
+	move.4	d0, (a0, d0)
+#else
+	moveai	a3, #%hi(main)
+	lea.1	d0, %lo(main)(a3)
+#endif
+
+	/*
+	 * Grab argc, argv[] from stack and set up d1, d2 with it.
+	 * Note that for FDPIC the calling convention and stack layout is
+	 * different than flat (see above)
+	 */
+	move.4	d1, (sp)	; argc
+#ifdef __UBICOM32_FDPIC__
+	lea.1	d2, 4(sp)	; argv = sp + 4
+#else
+	move.4	d2, 4(sp)	; argv = *(sp + 4)
+#endif
+
+#ifdef __UCLIBC_CTOR_DTOR__
+	/*
+	 * Load pointer to _init into d3
+	 */
+#ifdef __UBICOM32_FDPIC__
+	movei	d3, #%got_funcdesc_lo(_init)
+	move.4	d3, (a0, d3)
+#else
+	moveai	a3, #%hi(_init)
+	lea.1	d3, %lo(_init)(a3)
+#endif
+
+	/*
+	 * Load pointer to _fini into d4
+	 */
+#ifdef __UBICOM32_FDPIC__
+	movei	d4, #%got_funcdesc_lo(_fini)
+	move.4	d4, (a0, d4)
+#else
+	moveai	a3, #%hi(_fini)
+	lea.1	d4, %lo(_fini)(a3)
+#endif
+
+#else /* !__UCLIBC_CTOR_DTOR__ */
+	move.4	d3, #0		; _init
+	move.4	d4, #0		; _fini
+#endif
+
+#ifdef __UBICOM32_FDPIC__
+	move.4	d5, a1		; ldso _fini funcdesc (see dl-startup.h)
+#else
+	movei	d5, #0		; rtld_fini (not used)
+#endif
+
+	move.4	d6, sp		; Stack End.
+
+	/* Call the user's main function, and exit with its value.  But
+	   let the libc call main.  */
+#ifdef __UBICOM32_FDPIC__
+	call	a5, __uClibc_main
+#else
+	moveai	a5, #%hi(__uClibc_main)
+	calli	a5, %lo(__uClibc_main)(a5)
+#endif
+
+	bkpt #-1		; Crash if somehow `exit' does return.
--- /dev/null
+++ b/libc/sysdeps/linux/ubicom32/crti.S
@@ -0,0 +1,55 @@
+/*
+Copyright (C) 2009, Ubicom, Inc.
+Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+This file is part of the GNU C Library.
+
+The GNU C Library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public License as
+published by the Free Software Foundation; either version 2.1 of the
+License, or (at your option) any later version.
+
+In addition to the permissions in the GNU Lesser General Public
+License, the Free Software Foundation gives you unlimited
+permission to link the compiled version of this file with other
+programs, and to distribute those programs without any restriction
+coming from the use of this file.  (The GNU Lesser General Public
+License restrictions do apply in other respects; for example, they
+cover modification of the file, and distribution when not linked
+into another program.)
+
+The GNU C Library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with the GNU C Library; see the file COPYING.LIB.  If
+not, write to the Free Software Foundation, Inc., 675 Mass Ave,
+Cambridge, MA 02139, USA.  */
+
+/*
+ * This file just supplies function prologues for the .init and .fini
+ * sections.  It is linked in before crtbegin.o.
+ */
+	.file   "crti.o"
+	.ident  "GNU C crti.o"
+
+	.section .init
+	.align	2
+	.globl	_init
+	.type	_init, @function
+_init:
+	move.4 -4(sp)++, a5
+#ifdef __UBICOM32_FDPIC__
+	move.4 -4(sp)++, a0
+#endif
+
+	.section .fini
+	.align	2
+	.globl	_fini
+	.type	_fini, @function
+_fini:
+	move.4 -4(sp)++, a5
+#ifdef __UBICOM32_FDPIC__
+	move.4 -4(sp)++, a0
+#endif
--- /dev/null
+++ b/libc/sysdeps/linux/ubicom32/crtn.S
@@ -0,0 +1,52 @@
+/*
+Copyright (C) 2009, Ubicom, Inc.
+Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+This file is part of the GNU C Library.
+
+The GNU C Library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public License as
+published by the Free Software Foundation; either version 2.1 of the
+License, or (at your option) any later version.
+
+In addition to the permissions in the GNU Lesser General Public
+License, the Free Software Foundation gives you unlimited
+permission to link the compiled version of this file with other
+programs, and to distribute those programs without any restriction
+coming from the use of this file.  (The GNU Lesser General Public
+License restrictions do apply in other respects; for example, they
+cover modification of the file, and distribution when not linked
+into another program.)
+
+The GNU C Library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with the GNU C Library; see the file COPYING.LIB.  If
+not, write to the Free Software Foundation, Inc., 675 Mass Ave,
+Cambridge, MA 02139, USA.  */
+
+/*
+ * This file supplies function epilogues for the .init and .fini sections.
+ * It is linked in after all other files.
+ */
+
+	.file   "crtn.o"
+	.ident  "GNU C crtn.o"
+
+	.section .init
+#ifdef __UBICOM32_FDPIC__
+	/*
+	 * Note: the ABI doesn't specify that we need to restore a0 but we do
+	 * need to restore the stack ptr.
+	 */
+	move.4	a0, (sp)4++
+#endif
+	ret	(sp)4++
+
+	.section .fini
+#ifdef __UBICOM32_FDPIC__
+	move.4	a0, (sp)4++
+#endif
+	ret	(sp)4++
--- /dev/null
+++ b/libc/sysdeps/linux/ubicom32/crtreloc.c
@@ -0,0 +1,145 @@
+/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   written by Alexandre Oliva <aoliva@redhat.com>
+This file is part of the GNU C Library.
+
+The GNU C Library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public License as
+published by the Free Software Foundation; either version 2.1 of the
+License, or (at your option) any later version.
+
+In addition to the permissions in the GNU Lesser General Public
+License, the Free Software Foundation gives you unlimited
+permission to link the compiled version of this file with other
+programs, and to distribute those programs without any restriction
+coming from the use of this file.  (The GNU Lesser General Public
+License restrictions do apply in other respects; for example, they
+cover modification of the file, and distribution when not linked
+into another program.)
+
+The GNU C Library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with the GNU C Library; see the file COPYING.LIB.  If
+not, write to the Free Software Foundation, Inc., 675 Mass Ave,
+Cambridge, MA 02139, USA.  */
+
+#ifdef __UBICOM32_FDPIC__
+
+#include <sys/types.h>
+#include <link.h>
+
+/* This file is to be compiled into crt object files, to enable
+   executables to easily self-relocate.  */
+
+union word {
+    char c[4];
+    void *v;
+};
+
+/* Compute the runtime address of pointer in the range [p,e), and then
+   map the pointer pointed by it.  */
+static __always_inline void ***
+reloc_range_indirect (void ***p, void ***e,
+		      const struct elf32_fdpic_loadmap *map)
+{
+  while (p < e)
+    {
+      if (*p != (void **)-1)
+	{
+	  void *ptr = __reloc_pointer (*p, map);
+	  if (ptr != (void *)-1)
+	    {
+	      void *pt;
+	      if ((long)ptr & 3)
+		{
+		  unsigned char *c = ptr;
+		  int i;
+		  unsigned long v = 0;
+		  for (i = 0; i < 4; i++)
+		    v |= c[i] << 8 * i;
+		  pt = (void *)v;
+		}
+	      else
+		pt = *(void**)ptr;
+	      pt = __reloc_pointer (pt, map);
+	      if ((long)ptr & 3)
+		{
+		  unsigned char *c = ptr;
+		  int i;
+		  unsigned long v = (unsigned long)pt;
+		  for (i = 0; i < 4; i++, v >>= 8)
+		    c[i] = v;
+		}
+	      else
+		*(void**)ptr = pt;
+	    }
+	}
+      p++;
+    }
+  return p;
+}
+
+/* Call __reloc_range_indirect for the given range except for the last
+   entry, whose contents are only relocated.  It's expected to hold
+   the GOT value.  */
+attribute_hidden void*
+__self_reloc (const struct elf32_fdpic_loadmap *map,
+	      void ***p, void ***e)
+{
+  p = reloc_range_indirect (p, e-1, map);
+
+  if (p >= e)
+    return (void*)-1;
+
+  return __reloc_pointer (*p, map);
+}
+
+#if 0
+/* These are other functions that might be useful, but that we don't
+   need.  */
+
+/* Remap pointers in [p,e).  */
+static __always_inline void**
+reloc_range (void **p, void **e,
+	     const struct elf32_fdpic_loadmap *map)
+{
+  while (p < e)
+    {
+      *p = __reloc_pointer (*p, map);
+      p++;
+    }
+  return p;
+}
+
+/* Remap p, adjust e by the same offset, then map the pointers in the
+   range determined by them.  */
+void attribute_hidden
+__reloc_range (const struct elf32_fdpic_loadmap *map,
+	       void **p, void **e)
+{
+  void **old = p;
+
+  p = __reloc_pointer (p, map);
+  e += p - old;
+  reloc_range (p, e, map);
+}
+
+/* Remap p, adjust e by the same offset, then map pointers referenced
+   by the (unadjusted) pointers in the range.  Return the relocated
+   value of the last pointer in the range.  */
+void* attribute_hidden
+__reloc_range_indirect (const struct elf32_fdpic_loadmap *map,
+			void ***p, void ***e)
+{
+  void ***old = p;
+
+  p = __reloc_pointer (p, map);
+  e += p - old;
+  return reloc_range_indirect (p, e, map);
+}
+#endif
+
+#endif /* __UBICOM32_FDPIC__ */
--- /dev/null
+++ b/libc/sysdeps/linux/ubicom32/setjmp.S
@@ -0,0 +1,101 @@
+/*
+ * libc/sysdeps/linux/ubicom32/setjmp.S -- setjmp/sigsetjmp/longjmp for linux/ubicom32
+ *
+ * Copyright (C) 2009, Ubicom, Inc.
+ *
+ * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+ */
+
+/*
+ * _setjmp() for Ubicom32
+ *	This just does a tail-call to `__sigsetjmp (ARG, 0)'.  We cannot
+ *	do it in C because it must be a tail-call, so frame-unwinding in
+ *	setjmp doesn't clobber the state restored by longjmp.
+ */
+	.text
+	.global _setjmp
+	.type   _setjmp,@function
+_setjmp:
+	movei	d1, #0		/* savemask=0, don't save the mask */
+	jmpt.t	.L__sigsetjmp	/* don't use the public symbol as the
+				   link will jump through the plt */
+	.size _setjmp, . - _setjmp
+
+/*
+ * setjmp() for Ubicom32
+ *	This just does a tail-call to `__sigsetjmp (env, 1)'.  We cannot
+ *	do it in C because it must be a tail-call, so frame-unwinding in
+ *	setjmp doesn't clobber the state restored by longjmp.
+ */
+	.global setjmp
+	.type   setjmp,@function
+setjmp:
+	movei	d1, #1		/* savemask=1, to save the mask */
+	jmpt.t	.L__sigsetjmp	/* don't use the public symbol as the
+				   link will jump through the plt */
+	.size setjmp, . - setjmp
+
+/*
+ * __sigsetjmp() for Ubicom32
+ *     d0 holds sigjmp_buf and d1 holds the savemask. We will save the
+ *     frame and then just call __sigjmp_save to do the mask save.
+ */
+	.global __sigsetjmp
+	.type   __sigsetjmp,@function
+__sigsetjmp:
+.L__sigsetjmp:			/* private version used by setjmp, _setjmp */
+	movea	a3, d0		; A3 now holds the jmp buf that was passed in.
+	move.4	(a3)4++, d10
+	move.4	(a3)4++, d11
+	move.4	(a3)4++, d12
+	move.4	(a3)4++, d13
+	move.4  (a3)4++, a1
+	move.4  (a3)4++, a2
+	move.4  (a3)4++, a5
+	move.4  (a3)4++, a6
+	move.4  (a3)4++, a7
+
+	/*
+	 * The frame has been saved. Call _sigjmp_save to get sigmask saved. a5
+	 * still has the return address and it will go back to that.
+	 */
+#if defined(__UBICOM32_FDPIC__)
+	call	a3, __sigjmp_save
+#else
+	moveai	a3, #%hi(__sigjmp_save)
+	calli	a3, %lo(__sigjmp_save)(a3)
+#endif
+	.size __sigsetjmp, . - __sigsetjmp
+
+/*
+ * __longjmp() for Ubicom32
+ */
+	.global	__longjmp
+	.type   __longjmp,@function
+__longjmp:
+	movea	a3, d0		; A3 now holds the jmp buf that was passed in.
+	move.4  d10, (a3)4++
+	move.4  d11, (a3)4++
+	move.4  d12, (a3)4++
+	move.4  d13, (a3)4++
+	move.4  a1 , (a3)4++
+	move.4  a2 , (a3)4++
+	move.4  a5 , (a3)4++
+	move.4  a6 , (a3)4++
+	move.4  a7 , (a3)4++
+
+	/*
+	 * Test if d1 is zero. If it is we have to return 1 other wise return
+	 * content of d1
+	 */
+	sub.4	#0, #0, d1
+	jmpeq.t	2f
+	move.4	d0, d1		; d1 is non zero load it into d0
+	jmpt.t	3f
+
+2:	move.4	d0, #1
+3:	calli	a5, 0(a5)
+	.size __longjmp, . - __longjmp
+	.global __GI___longjmp
+	.hidden __GI___longjmp
+	.set __GI___longjmp,__longjmp
--- /dev/null
+++ b/libc/sysdeps/linux/ubicom32/sys/procfs.h
@@ -0,0 +1,122 @@
+/* Copyright (C) 1996, 1997, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_PROCFS_H
+#define _SYS_PROCFS_H	1
+
+/* This is somehow modelled after the file of the same name on SysVr4
+   systems.  It provides a definition of the core file format for ELF
+   used on Linux.  */
+
+#include <features.h>
+#include <signal.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/ucontext.h>
+#include <bits/wordsize.h>
+
+__BEGIN_DECLS
+
+#define ELF_NGREG		38
+
+typedef struct
+  {
+    union
+      {
+	unsigned long	pr_regs[32];
+	double		pr_dregs[16];
+      }			pr_fr;
+    unsigned long	__unused;
+    unsigned long	pr_fsr;
+    unsigned char	pr_qcnt;
+    unsigned char	pr_q_entrysize;
+    unsigned char	pr_en;
+    unsigned int	pr_q[64];
+  } elf_fpregset_t;
+
+typedef unsigned long elf_greg_t;
+typedef elf_greg_t elf_gregset_t[ELF_NGREG];
+
+struct elf_siginfo
+  {
+    int si_signo;			/* Signal number.  */
+    int si_code;			/* Extra code.  */
+    int si_errno;			/* Errno.  */
+  };
+
+/* Definitions to generate Intel SVR4-like core files.  These mostly
+   have the same names as the SVR4 types with "elf_" tacked on the
+   front to prevent clashes with linux definitions, and the typedef
+   forms have been avoided.  This is mostly like the SVR4 structure,
+   but more Linuxy, with things that Linux does not support and which
+   gdb doesn't really use excluded.  Fields present but not used are
+   marked with "XXX".  */
+struct elf_prstatus
+  {
+    struct elf_siginfo pr_info;		/* Info associated with signal.  */
+    short int pr_cursig;		/* Current signal.  */
+    unsigned long int pr_sigpend;	/* Set of pending signals.  */
+    unsigned long int pr_sighold;	/* Set of held signals.  */
+    __pid_t pr_pid;
+    __pid_t pr_ppid;
+    __pid_t pr_pgrp;
+    __pid_t pr_sid;
+    struct timeval pr_utime;		/* User time.  */
+    struct timeval pr_stime;		/* System time.  */
+    struct timeval pr_cutime;		/* Cumulative user time.  */
+    struct timeval pr_cstime;		/* Cumulative system time.  */
+    elf_gregset_t pr_reg;		/* GP registers.  */
+    int pr_fpvalid;			/* True if math copro being used.  */
+  };
+
+
+#define ELF_PRARGSZ     (80)    /* Number of chars for args.  */
+
+struct elf_prpsinfo
+  {
+    char pr_state;			/* Numeric process state.  */
+    char pr_sname;			/* Char for pr_state.  */
+    char pr_zomb;			/* Zombie.  */
+    char pr_nice;			/* Nice val.  */
+    unsigned long int pr_flag;		/* Flags.  */
+    unsigned short int pr_uid;
+    unsigned short int pr_gid;
+    int pr_pid, pr_ppid, pr_pgrp, pr_sid;
+    /* Lots missing */
+    char pr_fname[16];			/* Filename of executable.  */
+    char pr_psargs[ELF_PRARGSZ];	/* Initial part of arg list.  */
+  };
+
+/* Addresses.  */
+typedef void *psaddr_t;
+
+/* Register sets.  Linux has different names.  */
+typedef elf_gregset_t prgregset_t;
+typedef elf_fpregset_t prfpregset_t;
+
+/* We don't have any differences between processes and threads,
+   therefore have only one PID type.  */
+typedef __pid_t lwpid_t;
+
+
+typedef struct elf_prstatus prstatus_t;
+typedef struct elf_prpsinfo prpsinfo_t;
+
+__END_DECLS
+
+#endif	/* sys/procfs.h */
--- /dev/null
+++ b/libc/sysdeps/linux/ubicom32/sys/ucontext.h
@@ -0,0 +1,101 @@
+/* Copyright (C) 1998, 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_UCONTEXT_H
+#define _SYS_UCONTEXT_H	1
+
+#include <features.h>
+#include <signal.h>
+/*
+ * Location of the users' stored registers relative to D0.
+ * Usage is as an index into a gregset_t array or as u.u_ar0[XX].
+ */
+#define REG_D0           0
+#define REG_D1           1
+#define REG_D2           2
+#define REG_D3           3
+#define REG_D4           4
+#define REG_D5           5
+#define REG_D6           6
+#define REG_D7           7
+#define REG_D8           8
+#define REG_D9           9
+#define REG_D10          10
+#define REG_D11          11
+#define REG_D12          12
+#define REG_D13          13
+#define REG_D14          14
+#define REG_D15          15
+#define REG_A0           16
+#define REG_A1           17
+#define REG_A2           18
+#define REG_A3           19
+#define REG_A4           20
+#define REG_A5           21
+#define REG_A6           22
+#define REG_A7           23
+#define REG_SP           REG_A7
+#define REG_ACC0HI       24
+#define REG_ACC0LO       25
+#define REG_MAC_RC16     26
+#define REG_ACC1HI       27
+#define REG_ACC1LO       28
+#define REG_SOURCE3      29
+#define REG_INST_CNT     30
+#define REG_CSR          31
+#define REG_DUMMY_UNUSED 32
+#define REG_INT_MASK0    33
+#define REG_INT_MASK1    34
+#define REG_TRAP_CAUSE   35
+#define REG_PC           36
+#define REG_ORIGINAL_D0  37
+#define REG_FRAME_TYPE   38
+#define REG_PREVIOUS_PC  39 /* only usefull for debug */
+#define REG_NESTING_LEVEL 40
+#define REG_THREAD_TYPE  41
+
+/*
+ * A gregset_t is defined as an array type for compatibility with the reference
+ * source. This is important due to differences in the way the C language
+ * treats arrays and structures as parameters.
+ *
+ * Note that NGREG is really (sizeof (struct pt_regs) / sizeof (greg_t))
+ */
+
+#define NGREG   42
+typedef int greg_t;
+
+typedef greg_t  gregset_t[NGREG];
+
+typedef struct
+  {
+    gregset_t   gregs;		/* general register set */
+  } mcontext_t;
+
+
+/* Userlevel context.  */
+typedef struct ucontext
+  {
+    unsigned long   uc_flags;
+    struct ucontext *uc_link;
+    stack_t         uc_stack;
+    mcontext_t      uc_mcontext;
+    __sigset_t	    uc_sigmask;
+  } ucontext_t;
+
+#endif /* sys/ucontext.h */
--- /dev/null
+++ b/libc/sysdeps/linux/ubicom32/syscall.c
@@ -0,0 +1,32 @@
+/* vi: set sw=4 ts=4: */
+/* syscall for ubicom32/uClibc
+ *
+ * Copyright (C) 2008-2009 by Ubicom Inc.
+ * Copyright (C) 2002 by Erik Andersen <andersen@uclibc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Library General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <features.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/syscall.h>
+
+extern long syscall(long sysnum, long a, long b, long c, long d, long e, long f);
+long syscall(long sysnum, long a, long b, long c, long d, long e, long f)
+{
+	int __NR_syscall_number = sysnum;
+	return (long) INLINE_SYSCALL(syscall_number, 6, a, b, c, d, e, f);
+}
--- /dev/null
+++ b/libc/sysdeps/linux/ubicom32/vfork.S
@@ -0,0 +1,43 @@
+/*
+ * libc/sysdeps/linux/ubicom32/vfork.S -- 'vfork' syscall for linux/ubicom32
+ *
+ * Copyright (C) 2009, Ubicom, Inc.
+ *
+ * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+ */
+
+#include <sys/syscall.h>
+
+	.text
+	.type   vfork,@function
+	.global vfork
+vfork:
+	move.4	-4(sp)++, a5	; Save return address on the stack.
+	movei	d8, #__NR_vfork
+	__syscall
+
+	/*
+	 * You get here only if the syscall bombed. If things had worked out the
+	 * parent and child would have both returned to the instruction just after
+	 * the call to this function.  See the implementation in 
+	 * arch/ubicom32/kernel/process.c.
+	 */
+	move.4	a5, (sp)4++	; Pop the return address off the stack.
+;	movei	d1, #-125
+;	sub.4	#0, d0, d1
+;	jmplt.t	1f
+
+	;; We have an error.
+	sub.4	d0, #0, d0	; d0 = -res. Call __set_errno with that.
+#if defined(__UBICOM32_FDPIC__)
+	call	a3, __syscall_error
+#else
+	moveai	a3, #%hi(__syscall_error)
+	calli	a3, %lo(__syscall_error)(a3)	; __syscall_error will return -1 and not come back here.
+#endif
+1:
+	calli	a5, 0(a5)
+	.size vfork, . - vfork
+	.global __GI_vfork
+	.hidden __GI_vfork
+	.set __GI_vfork,vfork
--- a/libpthread/linuxthreads.old/pthread.c
+++ b/libpthread/linuxthreads.old/pthread.c
@@ -391,6 +391,10 @@ void __pthread_initialize_minimal(void)
 #endif
 
     __libc_multiple_threads_ptr = __libc_pthread_init (ptr_pthread_functions);
+#ifndef __ARCH_USE_MMU__
+    __pthread_initial_thread_tos =
+      (char *)(((long)CURRENT_STACK_FRAME + getpagesize()) & ~(getpagesize() - 1));
+#endif /* __ARCH_USE_MMU__ */
 }
 
 
--- /dev/null
+++ b/libpthread/linuxthreads.old/sysdeps/ubicom32/pt-machine.h
@@ -0,0 +1,68 @@
+/* Machine-dependent pthreads configuration and inline functions.
+
+   Copyright (C) 1996, 1997, 1998, 2000, 2002, 2003, 2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ralf Baechle <ralf@gnu.org>.
+   Based on the Alpha version by Richard Henderson <rth@tamu.edu>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, write to the Free Software Foundation, Inc.,
+   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#ifndef _PT_MACHINE_H
+#define _PT_MACHINE_H   1
+
+#include <features.h>
+
+/*
+ * XXX try to make this inline
+ */
+extern long int testandset (int *spinlock);
+
+#ifndef PT_EI
+#define PT_EI
+#else
+/* Spinlock implementation; required.  */
+
+/*
+ * testandset() is the basis for the pthread spin lock.
+ *
+ * This implementation only requires that we 'set' the state of *spinlock. As
+ * bset is allows us to atomically 'testandset' a single bit define our 'set' is
+ * such that we will set bit 0 (ignoring all other bits, which should also be
+ * zero).
+ * Return value of 1 implies that the bit was already set and is still
+ * set.
+ * Return value of 0 implies that the bit was not previously set but it
+ * now is.
+ */
+long int
+testandset (int *spinlock)
+{
+	int ret; 
+	__asm__ volatile (
+		"	move.4	%0, #0		\n\t" /* Assume that the bit is not currently set */
+		"	bset	%1, %1, #0	\n\t" /* Attempt to 'set' bit 0 */
+		"	jmpeq.t	1f		\n\t"
+		"	move.4	%0, #1		\n\t" /* Bit was already set, so return 1 */
+		" 1:				\n\t"
+		: "=r"(ret), "+U4"(*spinlock)
+		:
+		: "memory", "cc"
+		);
+	return ret;
+}
+#endif
+#endif /* pt-machine.h */
--- /dev/null
+++ b/libpthread/linuxthreads.old/sysdeps/ubicom32/tls.h
@@ -0,0 +1,26 @@
+/* Definitions for thread-local data handling.  linuxthreads/MIPS version.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _TLS_H
+#define _TLS_H
+#ifdef HAVE_TLS_SUPPORT
+#warning no tls support 
+#undef USE_TLS
+#endif
+#endif	/* tls.h */
--- /dev/null
+++ b/libc/sysdeps/linux/ubicom32/brk.c
@@ -0,0 +1,43 @@
+/* brk system call for Linux/HPPA.
+   Copyright (C) 1995, 1996, 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/syscall.h>
+#include <unistd.h>
+
+/* This must be initialized data because commons can't have aliases.  */
+void *__curbrk attribute_hidden = 0;
+
+libc_hidden_proto(brk)
+int
+brk (void *addr)
+{
+  void *newbrk;
+
+  __curbrk = newbrk = (void *) syscall(__NR_brk, addr);
+
+  if (newbrk < addr)
+    {
+      __set_errno (ENOMEM);
+      return -1;
+    }
+
+  return 0;
+}
+libc_hidden_def(brk)
--- a/utils/ldd.c
+++ b/utils/ldd.c
@@ -106,6 +106,11 @@
 #define ELFCLASSM	ELFCLASS32
 #endif
 
+#if defined(__ubicom32__)
+#define MATCH_MACHINE(x) (x == EM_UBICOM32)
+#define ELFCLASSM	ELFCLASS32
+#endif
+
 #ifndef MATCH_MACHINE
 # ifdef __linux__
 #  include <asm/elf.h>
--- /dev/null
+++ b/libc/sysdeps/linux/ubicom32/sys/user.h
@@ -0,0 +1,40 @@
+/* Copyright (C) 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_USER_H
+#define _SYS_USER_H 1
+
+#include <features.h>
+
+#include <asm/ptrace.h>
+
+struct user {
+	struct pt_regs	regs;			/* entire machine state */
+	size_t		u_tsize;		/* text size (pages) */
+	size_t		u_dsize;		/* data size (pages) */
+	size_t		u_ssize;		/* stack size (pages) */
+	unsigned long	start_code;		/* text starting address */
+	unsigned long	start_data;		/* data starting address */
+	unsigned long	start_stack;		/* stack starting address */
+	long int	signal;			/* signal causing core dump */
+	struct regs *	u_ar0;			/* help gdb find registers */
+	unsigned long	magic;			/* identifies a core file */
+	char		u_comm[32];		/* user command name */
+};
+
+#endif /* _SYS_USER_H */
--- /dev/null
+++ b/libpthread/nptl/sysdeps/unix/sysv/linux/ubicom32/bits/pthreadtypes.h
@@ -0,0 +1,181 @@
+/* Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_PTHREADTYPES_H
+#define _BITS_PTHREADTYPES_H	1
+
+#include <endian.h>
+
+#define __SIZEOF_PTHREAD_ATTR_T 36
+#define __SIZEOF_PTHREAD_MUTEX_T 24
+#define __SIZEOF_PTHREAD_MUTEXATTR_T 4
+#define __SIZEOF_PTHREAD_COND_T 48
+#define __SIZEOF_PTHREAD_COND_COMPAT_T 12
+#define __SIZEOF_PTHREAD_CONDATTR_T 4
+#define __SIZEOF_PTHREAD_RWLOCK_T 32
+#define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
+#define __SIZEOF_PTHREAD_BARRIER_T 20
+#define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+
+
+/* Thread identifiers.  The structure of the attribute type is not
+   exposed on purpose.  */
+typedef unsigned long int pthread_t;
+
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_ATTR_T];
+  long int __align;
+} pthread_attr_t;
+
+
+typedef struct __pthread_internal_slist
+{
+  struct __pthread_internal_slist *__next;
+} __pthread_slist_t;
+
+
+/* Data structures for mutex handling.  The structure of the attribute
+   type is not exposed on purpose.  */
+typedef union
+{
+  struct __pthread_mutex_s
+  {
+    int __lock;
+    unsigned int __count;
+    int __owner;
+    /* KIND must stay at this position in the structure to maintain
+       binary compatibility.  */
+    int __kind;
+    unsigned int __nusers;
+    __extension__ union
+    {
+      int __spins;
+      __pthread_slist_t __list;
+    };
+  } __data;
+  char __size[__SIZEOF_PTHREAD_MUTEX_T];
+  long int __align;
+} pthread_mutex_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_MUTEXATTR_T];
+  long int __align;
+} pthread_mutexattr_t;
+
+
+/* Data structure for conditional variable handling.  The structure of
+   the attribute type is not exposed on purpose.  */
+typedef union
+{
+  struct
+  {
+    int __lock;
+    unsigned int __futex;
+    __extension__ unsigned long long int __total_seq;
+    __extension__ unsigned long long int __wakeup_seq;
+    __extension__ unsigned long long int __woken_seq;
+    void *__mutex;
+    unsigned int __nwaiters;
+    unsigned int __broadcast_seq;
+  } __data;
+  char __size[__SIZEOF_PTHREAD_COND_T];
+  __extension__ long long int __align;
+} pthread_cond_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_CONDATTR_T];
+  long int __align;
+} pthread_condattr_t;
+
+
+/* Keys for thread-specific data */
+typedef unsigned int pthread_key_t;
+
+
+/* Once-only execution */
+typedef int pthread_once_t;
+
+
+#if defined __USE_UNIX98 || defined __USE_XOPEN2K
+/* Data structure for read-write lock variable handling.  The
+   structure of the attribute type is not exposed on purpose.  */
+typedef union
+{
+  struct
+  {
+    int __lock;
+    unsigned int __nr_readers;
+    unsigned int __readers_wakeup;
+    unsigned int __writer_wakeup;
+    unsigned int __nr_readers_queued;
+    unsigned int __nr_writers_queued;
+#if __BYTE_ORDER == __BIG_ENDIAN
+    unsigned char __pad1;
+    unsigned char __pad2;
+    unsigned char __shared;
+    /* FLAGS must stay at this position in the structure to maintain
+       binary compatibility.  */
+    unsigned char __flags;
+#else
+    /* FLAGS must stay at this position in the structure to maintain
+       binary compatibility.  */
+    unsigned char __flags;
+    unsigned char __shared;
+    unsigned char __pad1;
+    unsigned char __pad2;
+#endif
+    int __writer;
+  } __data;
+  char __size[__SIZEOF_PTHREAD_RWLOCK_T];
+  long int __align;
+} pthread_rwlock_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_RWLOCKATTR_T];
+  long int __align;
+} pthread_rwlockattr_t;
+#endif
+
+
+#ifdef __USE_XOPEN2K
+/* POSIX spinlock data type.  */
+typedef volatile int pthread_spinlock_t;
+
+
+/* POSIX barriers data type.  The structure of the type is
+   deliberately not exposed.  */
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_BARRIER_T];
+  long int __align;
+} pthread_barrier_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_BARRIERATTR_T];
+  int __align;
+} pthread_barrierattr_t;
+#endif
+
+
+#endif	/* bits/pthreadtypes.h */
--- /dev/null
+++ b/libpthread/nptl/sysdeps/unix/sysv/linux/ubicom32/bits/semaphore.h
@@ -0,0 +1,35 @@
+/* Copyright (C) 2002, 2005, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SEMAPHORE_H
+# error "Never use <bits/semaphore.h> directly; include <semaphore.h> instead."
+#endif
+
+
+#define __SIZEOF_SEM_T	16
+
+
+/* Value returned if `sem_open' failed.  */
+#define SEM_FAILED      ((sem_t *) 0)
+
+
+typedef union
+{
+  char __size[__SIZEOF_SEM_T];
+  long int __align;
+} sem_t;
