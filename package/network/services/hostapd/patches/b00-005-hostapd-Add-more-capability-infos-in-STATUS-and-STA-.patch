From dc6b64b96104fe96b84e5dfa3aea9130a4c3132a Mon Sep 17 00:00:00 2001
From: Bhagavathi Perumal S <bperumal@codeaurora.org>
Date: Thu, 5 Oct 2017 17:37:01 +0530
Subject: [PATCH] hostapd: Add more capability infos in STATUS and STA commands

These allow external programs to get max mcs, max tx power and
max nss, HT and VHT capabilities info of an interface or a STA
and also STA's extended capabilities info and DTIM period of BSS.

Signed-off-by: Bhagavathi Perumal S <bperumal@codeaurora.org>
---
 src/ap/ctrl_iface_ap.c         | 93 ++++++++++++++++++++++++++++++++++++++++--
 src/ap/ieee802_11.c            | 86 +++++++++++++++++++++++++++++++++++++-
 src/ap/ieee802_11.h            |  3 ++
 src/ap/ieee802_11_ht.c         | 24 ++++++++++-
 src/ap/ieee802_11_vht.c        | 18 ++++++++
 src/ap/sta_info.c              |  7 +++-
 src/ap/sta_info.h              |  6 +++
 src/common/ieee802_11_common.c |  4 ++
 src/common/ieee802_11_common.h |  2 +
 9 files changed, 235 insertions(+), 8 deletions(-)

--- a/src/ap/ctrl_iface_ap.c
+++ b/src/ap/ctrl_iface_ap.c
@@ -108,10 +108,22 @@ static int hostapd_get_sta_tx_rx(struct
 		if (!os_snprintf_error(buflen - len, ret))
 			len += ret;
 	}
-	ret = os_snprintf(buf + len, buflen - len, "\n");
+	ret = os_snprintf(buf + len, buflen - len, "\nmax_nss=%u\n",
+			  sta->max_nss);
 	if (!os_snprintf_error(buflen - len, ret))
 		len += ret;
 
+	if (sta->flags & WLAN_STA_VHT) {
+		ret = os_snprintf(buf + len, buflen - len, "max_vhtmcs=%u\n",
+				  sta->vht_maxmcs);
+		if(!os_snprintf_error(buflen - len, ret))
+			len += ret;
+	} else if (sta->flags & WLAN_STA_HT) {
+		ret = os_snprintf(buf + len, buflen - len, "max_mcs=%u\n",
+				  sta->ht_maxmcs);
+		if(!os_snprintf_error(buflen - len, ret))
+			len += ret;
+	}
 	return len;
 }
 
@@ -245,6 +257,33 @@ static int hostapd_ctrl_iface_sta_mib(st
 					sta->supp_op_classes[0]);
 		len += os_snprintf(buf + len, buflen - len, "\n");
 	}
+	ret = os_snprintf(buf + len, buflen - len,"max_txpower=%u\n",
+			  sta->max_tx_power);
+	if (!os_snprintf_error(buflen - len, ret))
+		len += ret;
+	if (sta->flags & WLAN_STA_VHT) {
+		res = os_snprintf(buf + len, buflen - len, "vht_caps_info=0x%08x\n",
+				  le_to_host32(sta->vht_capabilities->
+					       vht_capabilities_info));
+		if (!os_snprintf_error(buflen - len, res))
+			len += res;
+	}
+	if (sta->flags & WLAN_STA_HT) {
+		res = os_snprintf(buf + len, buflen - len, "ht_caps_info=0x%04x\n",
+				  le_to_host16(sta->ht_capabilities->
+					       ht_capabilities_info));
+		if (!os_snprintf_error(buflen - len, res))
+			len += res;
+	}
+	if (sta->ext_capability &&
+	    buflen - len > (unsigned) (15 + 2 * sta->ext_capability[0])) {
+		len += os_snprintf(buf + len, buflen - len,"ex-capability=");
+		len += wpa_snprintf_hex(buf + len,
+				buflen - len,
+				sta->ext_capability + 1,
+				sta->ext_capability[0]);
+		len += os_snprintf(buf + len, buflen - len,"\n");
+	}
 
 	return len;
 }
@@ -548,8 +587,10 @@ int hostapd_ctrl_iface_status(struct hos
 			      size_t buflen)
 {
 	struct hostapd_iface *iface = hapd->iface;
+	struct hostapd_hw_modes *mode = iface->current_mode;
 	int len = 0, ret;
 	size_t i;
+	u8 max_tx_power = 0;
 
 	ret = os_snprintf(buf + len, buflen - len,
 			  "state=%s\n"
@@ -620,18 +661,52 @@ int hostapd_ctrl_iface_status(struct hos
 	if (os_snprintf_error(buflen - len, ret))
 		return len;
 	len += ret;
+
 	if (iface->conf->ieee80211ac && !hapd->conf->disable_11ac) {
+		u16 rxmap = mode->vht_mcs_set[0] |
+			(mode->vht_mcs_set[1] << 8);
+		u16 txmap = mode->vht_mcs_set[4] |
+			(mode->vht_mcs_set[5] << 8);
 		ret = os_snprintf(buf + len, buflen - len,
 				  "vht_oper_chwidth=%d\n"
 				  "vht_oper_centr_freq_seg0_idx=%d\n"
-				  "vht_oper_centr_freq_seg1_idx=%d\n",
+				  "vht_oper_centr_freq_seg1_idx=%d\n"
+				  "vht_caps_info=%08x\n"
+				  "vht_max_mcs=%u\n",
 				  iface->conf->vht_oper_chwidth,
 				  iface->conf->vht_oper_centr_freq_seg0_idx,
-				  iface->conf->vht_oper_centr_freq_seg1_idx);
+				  iface->conf->vht_oper_centr_freq_seg1_idx,
+				  hapd->iconf->vht_capab,
+				  hostapd_vhtmaxmcs(rxmap,txmap));
+		if (os_snprintf_error(buflen - len, ret))
+			return len;
+		len += ret;
+	}
+	if (iface->conf->ieee80211n && !hapd->conf->disable_11n) {
+		ret = os_snprintf(buf + len, buflen - len,
+				  "ht_caps_info=%04x\n"
+				  "max_mcs=%u\n",
+				  hapd->iconf->ht_capab,
+				  hostapd_htmaxmcs(mode->mcs_set));
 		if (os_snprintf_error(buflen - len, ret))
 			return len;
 		len += ret;
 	}
+	if (mode->rates && mode->num_rates &&
+			(mode->num_rates <= WLAN_SUPP_RATES_MAX)) {
+		ret = os_snprintf(buf + len, buflen - len,
+				"max_rate=%u\n",
+				mode->rates[mode->num_rates-1]);
+		if (os_snprintf_error(buflen - len, ret))
+			return len;
+		len += ret;
+	}
+	ret = os_snprintf(buf + len, buflen - len,
+			"max_nss=%u\n",
+			hostapd_maxnss(hapd,NULL));
+	if (os_snprintf_error(buflen - len, ret))
+		return len;
+	len += ret;
 
 	for (i = 0; i < iface->num_bss; i++) {
 		struct hostapd_data *bss = iface->bss[i];
@@ -651,6 +726,21 @@ int hostapd_ctrl_iface_status(struct hos
 		len += ret;
 	}
 
+	for (i = 0; i < mode->num_channels; i++){
+		if (mode->channels[i].freq == iface->freq) {
+			max_tx_power = mode->channels[i].max_tx_power;
+			break;
+		}
+	}
+	ret = os_snprintf(buf + len, buflen - len,
+			  "max_txpower=%u\n"
+			  "dtim_period=%d\n",
+			  max_tx_power,
+			  hapd->conf->dtim_period);
+	if (os_snprintf_error(buflen - len, ret))
+		return len;
+	len += ret;
+
 	return len;
 }
 
--- a/src/ap/ieee802_11.c
+++ b/src/ap/ieee802_11.c
@@ -2137,8 +2137,17 @@ static u16 check_ext_capab(struct hostap
 	}
 #endif /* CONFIG_INTERWORKING */
 
-	if (ext_capab_ie_len > 0)
+	if (ext_capab_ie_len > 0){
 		sta->ecsa_supported = !!(ext_capab_ie[0] & BIT(2));
+		if (sta->ext_capability)
+			os_free(sta->ext_capability);
+		sta->ext_capability = os_malloc(1 + ext_capab_ie_len);
+		if (sta->ext_capability) {
+			sta->ext_capability[0] = ext_capab_ie_len;
+			os_memcpy(sta->ext_capability+1, ext_capab_ie,
+				  ext_capab_ie_len);
+		}
+	}
 
 	return WLAN_STATUS_SUCCESS;
 }
@@ -2350,6 +2359,9 @@ static u16 check_assoc_ies(struct hostap
 			       "mandatory HT PHY - reject association");
 		return WLAN_STATUS_ASSOC_DENIED_NO_HT;
 	}
+	if (sta->flags & WLAN_STA_HT)
+		sta->ht_maxmcs = hostapd_htmaxmcs(sta->ht_capabilities->
+						  supported_mcs_set);
 #endif /* CONFIG_IEEE80211N */
 
 #ifdef CONFIG_IEEE80211AC
@@ -2377,8 +2389,14 @@ static u16 check_assoc_ies(struct hostap
 		if (resp != WLAN_STATUS_SUCCESS)
 			return resp;
 	}
+	if (sta->flags & WLAN_STA_VHT)
+		sta->vht_maxmcs = hostapd_vhtmaxmcs(
+				  le_to_host16(sta->vht_capabilities->
+					       vht_supported_mcs_set.rx_map),
+				  le_to_host16(sta->vht_capabilities->
+					       vht_supported_mcs_set.tx_map));
 #endif /* CONFIG_IEEE80211AC */
-
+	sta->max_nss = hostapd_maxnss(hapd,sta);
 #ifdef CONFIG_P2P
 	if (elems.p2p) {
 		wpabuf_free(sta->p2p_ie);
@@ -2613,6 +2631,11 @@ static u16 check_assoc_ies(struct hostap
 		os_memcpy(sta->rrm_enabled_capa, elems.rrm_enabled,
 			  sizeof(sta->rrm_enabled_capa));
 
+	if (elems.power_capab)
+		sta->max_tx_power = elems.power_capab[1];
+	else
+		sta->max_tx_power = 0;
+
 	return WLAN_STATUS_SUCCESS;
 }
 
@@ -4402,4 +4425,63 @@ void ieee802_11_rx_from_unknown(struct h
 }
 
 
+u8 hostapd_maxnss(struct hostapd_data *hapd, struct sta_info *sta)
+{
+	u8 *mcs_set = NULL;
+	u16 mcs_map;
+	u8 ht_rx_nss = 0;
+	u8 vht_rx_nss = 1;
+	u8 mcs;
+	u8 ht_supported = 0;
+	u8 vht_supported = 0;
+	u8 i;
+
+	if (sta) {
+		if (sta->flags & WLAN_STA_HT) {
+			mcs_set =  sta->ht_capabilities->supported_mcs_set;
+			ht_supported = 1;
+		}
+		if (sta->flags & WLAN_STA_VHT) {
+			mcs_map = le_to_host16(sta->vht_capabilities->
+					       vht_supported_mcs_set.rx_map);
+			vht_supported = 1;
+		}
+	} else {
+		struct hostapd_config *conf = hapd->iface->conf;
+		struct hostapd_hw_modes *mode = hapd->iface->current_mode;
+
+		if (conf->ieee80211ac && !hapd->conf->disable_11ac) {
+			mcs_map = mode->vht_mcs_set[4] | \
+				  (mode->vht_mcs_set[5] << 8);
+			vht_supported = 1;
+		}
+		if (conf->ieee80211n && !hapd->conf->disable_11n) {
+			mcs_set = mode->mcs_set;
+			ht_supported = 1;
+		}
+	}
+	if (ht_supported && mcs_set != NULL) {
+		if (mcs_set[0])
+			ht_rx_nss++;
+		if (mcs_set[1])
+			ht_rx_nss++;
+		if (mcs_set[2])
+			ht_rx_nss++;
+		if (mcs_set[3])
+			ht_rx_nss++;
+	}
+	if (vht_supported) {
+		for (i = 7; i >= 0; i--) {
+			mcs = (mcs_map >> (2 * i)) & 0x03;
+			if (mcs != 0x03) {
+				vht_rx_nss = i + 1;
+				break;
+			}
+		}
+	}
+
+	return (ht_rx_nss > vht_rx_nss ? ht_rx_nss : vht_rx_nss);
+}
+
+
 #endif /* CONFIG_NATIVE_WINDOWS */
--- a/src/ap/ieee802_11.h
+++ b/src/ap/ieee802_11.h
@@ -152,3 +152,6 @@ void handle_auth_fils(struct hostapd_dat
 				 u16 resp, struct wpabuf *data, int pub));
 
 #endif /* IEEE802_11_H */
+u8 hostapd_vhtmaxmcs(u16 rx_vht_mcs_map, u16 tx_vht_mcs_map);
+u8 hostapd_htmaxmcs(u8 *mcsSet);
+u8 hostapd_maxnss(struct hostapd_data *hapd, struct sta_info *sta);
--- a/src/ap/ieee802_11_ht.c
+++ b/src/ap/ieee802_11_ht.c
@@ -361,7 +361,6 @@ u16 copy_sta_ht_capab(struct hostapd_dat
 	sta->flags |= WLAN_STA_HT;
 	os_memcpy(sta->ht_capabilities, ht_capab,
 		  sizeof(struct ieee80211_ht_capabilities));
-
 	return WLAN_STATUS_SUCCESS;
 }
 
@@ -517,3 +516,26 @@ void ap_ht2040_timeout(void *eloop_data,
 	iface->conf->secondary_channel = iface->secondary_ch;
 	ieee802_11_set_beacons(iface);
 }
+
+u8 hostapd_htmaxmcs(u8 *mcsSet)
+{
+	u8 rates[WLAN_SUPP_RATES_MAX];
+	u8 i;
+	u8 j=0;
+
+	for (i=0; i < WLAN_SUPP_HT_RATES_MAX; i++) {
+		if (mcsSet[i/8] & (1<<(i%8))) {
+			rates[j++] = i;
+		}
+		if (j == WLAN_SUPP_RATES_MAX) {
+			wpa_printf( MSG_WARNING,
+					"ht extended rate set too large;"
+					"only using %u rates",j);
+			break;
+		}
+	}
+	if (j <= WLAN_SUPP_RATES_MAX)
+		return rates[j - 1];
+
+	return 0;
+}
--- a/src/ap/ieee802_11_vht.c
+++ b/src/ap/ieee802_11_vht.c
@@ -492,3 +492,21 @@ void hostapd_get_vht_capab(struct hostap
 
 	neg_vht_cap->vht_capabilities_info = host_to_le32(cap);
 }
+
+u8 hostapd_vhtmaxmcs(u16 rx_vht_mcs_map, u16 tx_vht_mcs_map)
+{
+	u8 rx_max_mcs, tx_max_mcs, max_mcs;
+
+	if (rx_vht_mcs_map && tx_vht_mcs_map) {
+		/* Refer to IEEE P802.11ac/D7.0 Figure 8-401bs
+		 * for VHT MCS Map definition
+		 */
+		rx_max_mcs = rx_vht_mcs_map & 0x03;
+		tx_max_mcs = tx_vht_mcs_map & 0x03;
+		max_mcs = rx_max_mcs < tx_max_mcs ? rx_max_mcs : tx_max_mcs;
+		if (max_mcs < 0x03)
+			return 7 + max_mcs;
+	}
+
+	return 0;
+}
--- a/src/ap/sta_info.c
+++ b/src/ap/sta_info.c
@@ -356,6 +356,8 @@ void ap_free_sta(struct hostapd_data *ha
 	bin_clear_free(sta->owe_pmk, sta->owe_pmk_len);
 	crypto_ecdh_deinit(sta->owe_ecdh);
 #endif /* CONFIG_OWE */
+	if (sta->ext_capability)
+		os_free(sta->ext_capability);
 
 	os_free(sta);
 }
@@ -1342,7 +1344,7 @@ int ap_sta_flags_txt(u32 flags, char *bu
 	int res;
 
 	buf[0] = '\0';
-	res = os_snprintf(buf, buflen, "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
+	res = os_snprintf(buf, buflen, "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
 			  (flags & WLAN_STA_AUTH ? "[AUTH]" : ""),
 			  (flags & WLAN_STA_ASSOC ? "[ASSOC]" : ""),
 			  (flags & WLAN_STA_AUTHORIZED ? "[AUTHORIZED]" : ""),
@@ -1362,7 +1364,8 @@ int ap_sta_flags_txt(u32 flags, char *bu
 			  (flags & WLAN_STA_VHT ? "[VHT]" : ""),
 			  (flags & WLAN_STA_VENDOR_VHT ? "[VENDOR_VHT]" : ""),
 			  (flags & WLAN_STA_WNM_SLEEP_MODE ?
-			   "[WNM_SLEEP_MODE]" : ""));
+                           "[WNM_SLEEP_MODE]" : ""),
+			  (flags & WLAN_STA_HT ? "[HT]" : ""));
 	if (os_snprintf_error(buflen, res))
 		res = -1;
 
--- a/src/ap/sta_info.h
+++ b/src/ap/sta_info.h
@@ -47,6 +47,7 @@
 /* Maximum number of supported rates (from both Supported Rates and Extended
  * Supported Rates IEs). */
 #define WLAN_SUPP_RATES_MAX 32
+#define WLAN_SUPP_HT_RATES_MAX 77
 
 struct hostapd_data;
 
@@ -257,6 +258,11 @@ struct sta_info {
 	u8 last_tk[WPA_TK_MAX_LEN];
 	size_t last_tk_len;
 #endif /* CONFIG_TESTING_OPTIONS */
+	u8 max_tx_power;
+	u8 vht_maxmcs;
+	u8 ht_maxmcs;
+	u8 max_nss;
+	u8 *ext_capability;
 };
 
 
--- a/src/common/ieee802_11_common.c
+++ b/src/common/ieee802_11_common.c
@@ -352,6 +352,10 @@ ParseRes ieee802_11_parse_elems(const u8
 			elems->rsn_ie_len = elen;
 			break;
 		case WLAN_EID_PWR_CAPABILITY:
+			if (elen < 2)
+				break;
+			elems->power_capab = pos;
+			elems->power_capab_len= elen;
 			break;
 		case WLAN_EID_SUPPORTED_CHANNELS:
 			elems->supp_channels = pos;
--- a/src/common/ieee802_11_common.h
+++ b/src/common/ieee802_11_common.h
@@ -79,6 +79,7 @@ struct ieee802_11_elems {
 	const u8 *fils_pk;
 	const u8 *fils_nonce;
 	const u8 *owe_dh;
+	const u8 *power_capab;
 
 	u8 ssid_len;
 	u8 supp_rates_len;
@@ -122,6 +123,7 @@ struct ieee802_11_elems {
 	u8 fils_wrapped_data_len;
 	u8 fils_pk_len;
 	u8 owe_dh_len;
+	u8 power_capab_len;
 
 	struct mb_ies_info mb_ies;
 };
