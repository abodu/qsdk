--- a/hostapd/config_file.c
+++ b/hostapd/config_file.c
@@ -3156,6 +3156,10 @@ static int hostapd_config_fill(struct ho
 		conf->local_pwr_constraint = val;
 	} else if (os_strcmp(buf, "spectrum_mgmt_required") == 0) {
 		conf->spectrum_mgmt_required = atoi(pos);
+	} else if (os_strcmp(buf, "vht_2g_enabled") == 0) {
+		bss->vht_2g_enabled = atoi(pos);
+	} else if (os_strcmp(buf, "vendor_vht_2g_enabled") == 0) {
+		bss->vendor_vht_2g_enabled = atoi(pos);
 	} else {
 		wpa_printf(MSG_ERROR,
 			   "Line %d: unknown configuration item '%s'",
--- a/src/ap/ap_config.h
+++ b/src/ap/ap_config.h
@@ -512,6 +512,8 @@ struct hostapd_bss_config {
 	u8 bss_load_test[5];
 	u8 bss_load_test_set;
 #endif /* CONFIG_TESTING_OPTIONS */
+	int vht_2g_enabled;
+	int vendor_vht_2g_enabled;
 };
 
 
--- a/src/ap/beacon.c
+++ b/src/ap/beacon.c
@@ -346,6 +346,12 @@ static u8 * hostapd_gen_probe_resp(struc
 #endif /* CONFIG_P2P */
 	if (hapd->conf->vendor_elements)
 		buflen += wpabuf_len(hapd->conf->vendor_elements);
+	if (hapd->conf->vht_2g_enabled)
+		buflen += (sizeof(struct ieee80211_vht_capabilities) + 2 +
+			   sizeof(struct ieee80211_vht_operation) + 2);
+	if (hapd->conf->vendor_vht_2g_enabled)
+		buflen += (sizeof(struct ieee80211_vht_capabilities) + 2 +
+			   sizeof(struct ieee80211_vht_operation) + 2 + 7);
 	resp = os_zalloc(buflen);
 	if (resp == NULL)
 		return NULL;
@@ -411,8 +417,15 @@ static u8 * hostapd_gen_probe_resp(struc
 	pos = hostapd_add_csa_elems(hapd, pos, (u8 *)resp,
 				    &hapd->iface->cs_c_off_proberesp);
 #ifdef CONFIG_IEEE80211AC
-	pos = hostapd_eid_vht_capabilities(hapd, pos);
-	pos = hostapd_eid_vht_operation(hapd, pos);
+	if ((hapd->iconf->ieee80211ac && !hapd->conf->disable_11ac) ||
+		hapd->conf->vht_2g_enabled) {
+		pos = hostapd_eid_vht_capabilities(hapd, pos);
+		pos = hostapd_eid_vht_operation(hapd, pos);
+	}
+
+	if (hapd->conf->vendor_vht_2g_enabled)
+		pos = hostapd_eid_vendor_vht_2g_cap(hapd, pos);
+
 #endif /* CONFIG_IEEE80211AC */
 
 	/* Wi-Fi Alliance WMM */
@@ -756,6 +769,15 @@ int ieee802_11_build_ap_params(struct ho
 #endif /* CONFIG_P2P */
 	if (hapd->conf->vendor_elements)
 		tail_len += wpabuf_len(hapd->conf->vendor_elements);
+
+	if (hapd->conf->vht_2g_enabled)
+		tail_len += (sizeof(struct ieee80211_vht_capabilities) + 2 +
+			     sizeof(struct ieee80211_vht_operation) + 2);
+
+	if (hapd->conf->vendor_vht_2g_enabled)
+		tail_len += (sizeof(struct ieee80211_vht_capabilities) + 2 +
+			     sizeof(struct ieee80211_vht_operation) + 2 + 7);
+
 	tailpos = tail = os_malloc(tail_len);
 	if (head == NULL || tail == NULL) {
 		wpa_printf(MSG_ERROR, "Failed to set beacon data");
@@ -841,8 +863,13 @@ int ieee802_11_build_ap_params(struct ho
 	tailpos = hostapd_add_csa_elems(hapd, tailpos, tail,
 					&hapd->iface->cs_c_off_beacon);
 #ifdef CONFIG_IEEE80211AC
-	tailpos = hostapd_eid_vht_capabilities(hapd, tailpos);
-	tailpos = hostapd_eid_vht_operation(hapd, tailpos);
+	if ((hapd->iconf->ieee80211ac && !hapd->conf->disable_11ac) ||
+		hapd->conf->vht_2g_enabled) {
+		tailpos = hostapd_eid_vht_capabilities(hapd, tailpos);
+		tailpos = hostapd_eid_vht_operation(hapd, tailpos);
+	}
+	if (hapd->conf->vendor_vht_2g_enabled)
+		tailpos = hostapd_eid_vendor_vht_2g_cap(hapd, tailpos);
 #endif /* CONFIG_IEEE80211AC */
 
 	/* Wi-Fi Alliance WMM */
--- a/src/ap/ieee802_11.c
+++ b/src/ap/ieee802_11.c
@@ -947,6 +947,14 @@ static u16 check_assoc_ies(struct hostap
 			       "mandatory VHT PHY - reject association");
 		return WLAN_STATUS_ASSOC_DENIED_NO_VHT;
 	}
+
+	if (hapd->conf->vendor_vht_2g_enabled) {
+		resp = copy_sta_vendor_vht_2g_cap(hapd, sta,
+						  elems.vendor_vht_2g_cap,
+						  elems.vendor_vht_2g_cap_len);
+		if (resp != WLAN_STATUS_SUCCESS)
+			return resp;
+	}
 #endif /* CONFIG_IEEE80211AC */
 
 #ifdef CONFIG_P2P
@@ -1224,8 +1232,14 @@ static void send_assoc_resp(struct hosta
 #endif /* CONFIG_IEEE80211N */
 
 #ifdef CONFIG_IEEE80211AC
-	p = hostapd_eid_vht_capabilities(hapd, p);
-	p = hostapd_eid_vht_operation(hapd, p);
+	if ((hapd->iconf->ieee80211ac && !hapd->conf->disable_11ac) ||
+		hapd->conf->vht_2g_enabled) {
+		p = hostapd_eid_vht_capabilities(hapd, p);
+		p = hostapd_eid_vht_operation(hapd, p);
+	}
+	if (hapd->conf->vendor_vht_2g_enabled &&
+	    (sta->flags & WLAN_STA_VENDOR_VHT_2G_ENABLED))
+		p = hostapd_eid_vendor_vht_2g_cap(hapd, p);
 #endif /* CONFIG_IEEE80211AC */
 
 	p = hostapd_eid_ext_capab(hapd, p);
--- a/src/ap/ieee802_11.h
+++ b/src/ap/ieee802_11.h
@@ -58,6 +58,9 @@ void hostapd_get_vht_capab(struct hostap
 			   struct ieee80211_vht_capabilities *neg_vht_cap);
 u16 copy_sta_ht_capab(struct hostapd_data *hapd, struct sta_info *sta,
 		      const u8 *ht_capab, size_t ht_capab_len);
+u16 copy_sta_vendor_vht_2g_cap(struct hostapd_data *hapd, struct sta_info *sta,
+			       const u8 *vht_capab, size_t vht_capab_len);
+
 void update_ht_state(struct hostapd_data *hapd, struct sta_info *sta);
 u16 copy_sta_vht_capab(struct hostapd_data *hapd, struct sta_info *sta,
 		       const u8 *vht_capab, size_t vht_capab_len);
@@ -82,6 +85,7 @@ u8 * hostapd_eid_time_zone(struct hostap
 int hostapd_update_time_adv(struct hostapd_data *hapd);
 void hostapd_client_poll_ok(struct hostapd_data *hapd, const u8 *addr);
 u8 * hostapd_eid_bss_max_idle_period(struct hostapd_data *hapd, u8 *eid);
+u8 * hostapd_eid_vendor_vht_2g_cap(struct hostapd_data *hapd, u8 *frm);
 
 #ifdef CONFIG_IEEE80211N
 void hostapd_trigger_20mhz(struct hostapd_iface *iface);
--- a/src/ap/ieee802_11_vht.c
+++ b/src/ap/ieee802_11_vht.c
@@ -24,8 +24,7 @@ u8 * hostapd_eid_vht_capabilities(struct
 	struct ieee80211_vht_capabilities *cap;
 	u8 *pos = eid;
 
-	if (!hapd->iconf->ieee80211ac || !hapd->iface->current_mode ||
-	    hapd->conf->disable_11ac)
+	if (!hapd->iface->current_mode)
 		return eid;
 
 	*pos++ = WLAN_EID_VHT_CAP;
@@ -51,9 +50,6 @@ u8 * hostapd_eid_vht_operation(struct ho
 	struct ieee80211_vht_operation *oper;
 	u8 *pos = eid;
 
-	if (!hapd->iconf->ieee80211ac || hapd->conf->disable_11ac)
-		return eid;
-
 	*pos++ = WLAN_EID_VHT_OPERATION;
 	*pos++ = sizeof(*oper);
 
@@ -109,6 +105,73 @@ u16 copy_sta_vht_capab(struct hostapd_da
 }
 
 
+u16 copy_sta_vendor_vht_2g_cap(struct hostapd_data *hapd,
+			       struct sta_info *sta,
+			       const u8 *vendor_vht_capab,
+			       size_t capab_len)
+{
+	const u8 *vht_capab;
+	int vht_capab_len;
+
+	if (!vendor_vht_capab ||
+	    capab_len < (sizeof(struct ieee80211_vht_capabilities) + 7)) {
+		return WLAN_STATUS_SUCCESS;
+	}
+	/* The VHT cap embed in vendor VHT with offset 7 */
+	vht_capab = vendor_vht_capab + 7;
+	vht_capab_len = vendor_vht_capab[6];
+
+	/* Attention: If the standard VHT IE and Vendor specific VHT IE
+	 * existed at the same time, we overwrite the standard VHT with the
+	 * content of Vendor VHT IE. The formsat of the VHT cap IE which ebeded
+	 * in the vendor IE is the same as the standard VHT cap IE
+	 */
+	if (!vht_capab ||
+	    vht_capab_len < sizeof(struct ieee80211_vht_capabilities)) {
+		sta->flags &= ~WLAN_STA_VHT;
+		sta->flags &= ~WLAN_STA_VENDOR_VHT_2G_ENABLED;
+		os_free(sta->vht_capabilities);
+		sta->vht_capabilities = NULL;
+		return WLAN_STATUS_SUCCESS;
+	    }
+
+	if (sta->vht_capabilities == NULL) {
+		sta->vht_capabilities =
+			os_zalloc(sizeof(struct ieee80211_vht_capabilities));
+		if (sta->vht_capabilities == NULL)
+			return WLAN_STATUS_UNSPECIFIED_FAILURE;
+	}
+
+	sta->flags |= WLAN_STA_VHT;
+	sta->flags |= WLAN_STA_VENDOR_VHT_2G_ENABLED;
+	os_memcpy(sta->vht_capabilities, vht_capab,
+		  sizeof(struct ieee80211_vht_capabilities));
+	return WLAN_STATUS_SUCCESS;
+}
+
+u8 * hostapd_eid_vendor_vht_2g_cap(struct hostapd_data *hapd, u8 *frm)
+{
+	u8 *pos = frm;
+	u32 vendor_type;
+
+	if (!hapd->iface->current_mode)
+		return frm;
+
+	*pos++ = WLAN_EID_VENDOR_SPECIFIC;
+	*pos++ = (5 +		/* The Vendor OUI, type and subtype */
+		  2 + sizeof(struct ieee80211_vht_capabilities) +
+		  2 + sizeof(struct ieee80211_vht_operation));
+
+	vendor_type = (OUI_BROADCOM << 8) | VENDOR_VHT_2G_TYPE;
+	*((be32 *)pos) = host_to_be32(vendor_type);
+	pos += sizeof(u32);
+	*pos++ = VENDOR_VHT_2G_SUBTYPE;
+
+	pos = hostapd_eid_vht_capabilities(hapd, pos);
+	pos = hostapd_eid_vht_operation(hapd, pos);
+	return pos;
+}
+
 u16 set_sta_vht_opmode(struct hostapd_data *hapd, struct sta_info *sta,
 		       const u8 *vht_oper_notif)
 {
--- a/src/ap/sta_info.h
+++ b/src/ap/sta_info.h
@@ -28,6 +28,7 @@
 #define WLAN_STA_VHT BIT(18)
 #define WLAN_STA_WNM_SLEEP_MODE BIT(19)
 #define WLAN_STA_VHT_OPMODE_ENABLED BIT(20)
+#define WLAN_STA_VENDOR_VHT_2G_ENABLED BIT(21)
 #define WLAN_STA_PENDING_DISASSOC_CB BIT(29)
 #define WLAN_STA_PENDING_DEAUTH_CB BIT(30)
 #define WLAN_STA_NONERP BIT(31)
--- a/src/common/ieee802_11_common.c
+++ b/src/common/ieee802_11_common.c
@@ -128,6 +128,13 @@ static int ieee802_11_parse_vendor_speci
 			elems->vendor_ht_cap = pos;
 			elems->vendor_ht_cap_len = elen;
 			break;
+		case VENDOR_VHT_2G_TYPE:
+			if (pos[4] == VENDOR_VHT_2G_SUBTYPE) {
+				elems->vendor_vht_2g_cap = pos;
+				elems->vendor_vht_2g_cap_len = elen;
+			} else
+				return -1;
+			break;
 		default:
 			wpa_printf(MSG_EXCESSIVE, "Unknown Broadcom "
 				   "information element ignored "
--- a/src/common/ieee802_11_common.h
+++ b/src/common/ieee802_11_common.h
@@ -32,6 +32,7 @@ struct ieee802_11_elems {
 	const u8 *vht_operation;
 	const u8 *vht_opmode_notif;
 	const u8 *vendor_ht_cap;
+	const u8 *vendor_vht_2g_cap;
 	const u8 *p2p;
 	const u8 *wfd;
 	const u8 *link_id;
@@ -63,6 +64,7 @@ struct ieee802_11_elems {
 	u8 vht_capabilities_len;
 	u8 vht_operation_len;
 	u8 vendor_ht_cap_len;
+	u8 vendor_vht_2g_cap_len;
 	u8 p2p_len;
 	u8 wfd_len;
 	u8 interworking_len;
--- a/src/common/ieee802_11_defs.h
+++ b/src/common/ieee802_11_defs.h
@@ -1067,6 +1067,8 @@ enum wifi_display_subelem {
 
 
 #define OUI_BROADCOM 0x00904c /* Broadcom (Epigram) */
+#define VENDOR_VHT_2G_TYPE       0x04
+#define VENDOR_VHT_2G_SUBTYPE	 0x08
 
 #define VENDOR_HT_CAPAB_OUI_TYPE 0x33 /* 00-90-4c:0x33 */
 
